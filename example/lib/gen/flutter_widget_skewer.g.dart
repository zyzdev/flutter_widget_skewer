// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by FlutterWidgetSkewerBuilder

import 'dart:ui' as ui;
import 'dart:ui';
import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart' as m show RefreshCallback;
import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/services.dart';

/// Chain a Widget with other widget that takes a child parameter.
extension FlutterWidgetSkewer on Widget {
  Widget cupertinoFormRow({Key? key, Widget? prefix, EdgeInsetsGeometry? padding, Widget? helper, Widget? error,}) =>
    CupertinoFormRow(child: this, key: key, prefix: prefix, padding: padding, helper: helper, error: error,);

  Widget cupertinoTextSelectionToolbarButton({Key? key, VoidCallback? onPressed,}) =>
    CupertinoTextSelectionToolbarButton(child: this, key: key, onPressed: onPressed,);

  Widget cupertinoButton({Key? key, CupertinoButtonSize sizeStyle = CupertinoButtonSize.large, EdgeInsetsGeometry? padding, Color? color, Color disabledColor = CupertinoColors.quaternarySystemFill, double? minSize, double? pressedOpacity = 0.4, BorderRadius? borderRadius, AlignmentGeometry alignment = Alignment.center, Color? focusColor, FocusNode? focusNode, ValueChanged<bool>? onFocusChange, bool autofocus = false, VoidCallback? onLongPress, required VoidCallback onPressed,}) =>
    CupertinoButton(child: this, key: key, sizeStyle: sizeStyle, padding: padding, color: color, disabledColor: disabledColor, minSize: minSize, pressedOpacity: pressedOpacity, borderRadius: borderRadius, alignment: alignment, focusColor: focusColor, focusNode: focusNode, onFocusChange: onFocusChange, autofocus: autofocus, onLongPress: onLongPress, onPressed: onPressed,);

  Widget cupertinoButtontinted({Key? key, CupertinoButtonSize sizeStyle = CupertinoButtonSize.large, EdgeInsetsGeometry? padding, Color? color, Color disabledColor = CupertinoColors.tertiarySystemFill, double? minSize, double? pressedOpacity = 0.4, BorderRadius? borderRadius, AlignmentGeometry alignment = Alignment.center, Color? focusColor, FocusNode? focusNode, ValueChanged<bool>? onFocusChange, bool autofocus = false, VoidCallback? onLongPress, required VoidCallback onPressed,}) =>
    CupertinoButton.tinted(child: this, key: key, sizeStyle: sizeStyle, padding: padding, color: color, disabledColor: disabledColor, minSize: minSize, pressedOpacity: pressedOpacity, borderRadius: borderRadius, alignment: alignment, focusColor: focusColor, focusNode: focusNode, onFocusChange: onFocusChange, autofocus: autofocus, onLongPress: onLongPress, onPressed: onPressed,);

  Widget cupertinoButtonfilled({Key? key, CupertinoButtonSize sizeStyle = CupertinoButtonSize.large, EdgeInsetsGeometry? padding, Color disabledColor = CupertinoColors.tertiarySystemFill, double? minSize, double? pressedOpacity = 0.4, BorderRadius? borderRadius, AlignmentGeometry alignment = Alignment.center, Color? focusColor, FocusNode? focusNode, ValueChanged<bool>? onFocusChange, bool autofocus = false, VoidCallback? onLongPress, required VoidCallback onPressed,}) =>
    CupertinoButton.filled(child: this, key: key, sizeStyle: sizeStyle, padding: padding, disabledColor: disabledColor, minSize: minSize, pressedOpacity: pressedOpacity, borderRadius: borderRadius, alignment: alignment, focusColor: focusColor, focusNode: focusNode, onFocusChange: onFocusChange, autofocus: autofocus, onLongPress: onLongPress, onPressed: onPressed,);

  Widget cupertinoPopupSurface({Key? key, bool isSurfacePainted = true,}) =>
    CupertinoPopupSurface(child: this, key: key, isSurfacePainted: isSurfacePainted,);

  Widget cupertinoActionSheetAction({Key? key, required VoidCallback onPressed, bool isDefaultAction = false, bool isDestructiveAction = false,}) =>
    CupertinoActionSheetAction(child: this, key: key, onPressed: onPressed, isDefaultAction: isDefaultAction, isDestructiveAction: isDestructiveAction,);

  Widget cupertinoDialogAction({Key? key, VoidCallback? onPressed, bool isDefaultAction = false, bool isDestructiveAction = false, TextStyle? textStyle,}) =>
    CupertinoDialogAction(child: this, key: key, onPressed: onPressed, isDefaultAction: isDefaultAction, isDestructiveAction: isDestructiveAction, textStyle: textStyle,);

  Widget cupertinoContextMenu({Key? key, required List<Widget> actions, bool enableHapticFeedback = false,}) =>
    CupertinoContextMenu(child: this, key: key, actions: actions, enableHapticFeedback: enableHapticFeedback,);

  Widget cupertinoPageTransition({Key? key, required Animation<double> primaryRouteAnimation, required Animation<double> secondaryRouteAnimation, required bool linearTransition,}) =>
    CupertinoPageTransition(child: this, key: key, primaryRouteAnimation: primaryRouteAnimation, secondaryRouteAnimation: secondaryRouteAnimation, linearTransition: linearTransition,);

  Widget cupertinoFullscreenDialogTransition({Key? key, required Animation<double> primaryRouteAnimation, required Animation<double> secondaryRouteAnimation, required bool linearTransition,}) =>
    CupertinoFullscreenDialogTransition(child: this, key: key, primaryRouteAnimation: primaryRouteAnimation, secondaryRouteAnimation: secondaryRouteAnimation, linearTransition: linearTransition,);

  Widget cupertinoPageScaffold({Key? key, ObstructingPreferredSizeWidget? navigationBar, Color? backgroundColor, bool resizeToAvoidBottomInset = true,}) =>
    CupertinoPageScaffold(child: this, key: key, navigationBar: navigationBar, backgroundColor: backgroundColor, resizeToAvoidBottomInset: resizeToAvoidBottomInset,);

  Widget cupertinoPageScaffoldBackgroundColor({required Color color, Key? key,}) =>
    CupertinoPageScaffoldBackgroundColor(child: this, color: color, key: key,);

  Widget cupertinoUserInterfaceLevel({Key? key, required CupertinoUserInterfaceLevelData data,}) =>
    CupertinoUserInterfaceLevel(child: this, key: key, data: data,);

  Widget cupertinoContextMenuAction({Key? key, bool isDefaultAction = false, bool isDestructiveAction = false, VoidCallback? onPressed, IconData? trailingIcon,}) =>
    CupertinoContextMenuAction(child: this, key: key, isDefaultAction: isDefaultAction, isDestructiveAction: isDestructiveAction, onPressed: onPressed, trailingIcon: trailingIcon,);

  Widget cupertinoTheme({Key? key, required CupertinoThemeData data,}) =>
    CupertinoTheme(child: this, key: key, data: data,);

  Widget inheritedCupertinoTheme({Key? key, required CupertinoTheme theme,}) =>
    InheritedCupertinoTheme(child: this, key: key, theme: theme,);

  Widget cupertinoDesktopTextSelectionToolbarButton({Key? key, required VoidCallback onPressed,}) =>
    CupertinoDesktopTextSelectionToolbarButton(child: this, key: key, onPressed: onPressed,);

  Widget textButtonTheme({Key? key, required TextButtonThemeData data,}) =>
    TextButtonTheme(child: this, key: key, data: data,);

  Widget drawerHeader({Key? key, Decoration? decoration, EdgeInsetsGeometry? margin = const EdgeInsets.only(bottom: 8.0), EdgeInsetsGeometry padding = const EdgeInsets.fromLTRB(16.0, 16.0, 16.0, 8.0), Duration duration = const Duration(milliseconds: 250), Curve curve = Curves.fastOutSlowIn,}) =>
    DrawerHeader(child: this, key: key, decoration: decoration, margin: margin, padding: padding, duration: duration, curve: curve,);

  Widget progressIndicatorTheme({Key? key, required ProgressIndicatorThemeData data,}) =>
    ProgressIndicatorTheme(child: this, key: key, data: data,);

  Widget materialButton({Key? key, required VoidCallback onPressed, VoidCallback? onLongPress, ValueChanged<bool>? onHighlightChanged, MouseCursor? mouseCursor, ButtonTextTheme? textTheme, Color? textColor, Color? disabledTextColor, Color? color, Color? disabledColor, Color? focusColor, Color? hoverColor, Color? highlightColor, Color? splashColor, Brightness? colorBrightness, double? elevation, double? focusElevation, double? hoverElevation, double? highlightElevation, double? disabledElevation, EdgeInsetsGeometry? padding, VisualDensity? visualDensity, ShapeBorder? shape, Clip clipBehavior = Clip.none, FocusNode? focusNode, bool autofocus = false, MaterialTapTargetSize? materialTapTargetSize, Duration? animationDuration, double? minWidth, double? height, bool enableFeedback = true,}) =>
    MaterialButton(child: this, key: key, onPressed: onPressed, onLongPress: onLongPress, onHighlightChanged: onHighlightChanged, mouseCursor: mouseCursor, textTheme: textTheme, textColor: textColor, disabledTextColor: disabledTextColor, color: color, disabledColor: disabledColor, focusColor: focusColor, hoverColor: hoverColor, highlightColor: highlightColor, splashColor: splashColor, colorBrightness: colorBrightness, elevation: elevation, focusElevation: focusElevation, hoverElevation: hoverElevation, highlightElevation: highlightElevation, disabledElevation: disabledElevation, padding: padding, visualDensity: visualDensity, shape: shape, clipBehavior: clipBehavior, focusNode: focusNode, autofocus: autofocus, materialTapTargetSize: materialTapTargetSize, animationDuration: animationDuration, minWidth: minWidth, height: height, enableFeedback: enableFeedback,);

  Widget gridTile({Key? key, Widget? header, Widget? footer,}) =>
    GridTile(child: this, key: key, header: header, footer: footer,);

  Widget material({Key? key, MaterialType type = MaterialType.canvas, double elevation = 0.0, Color? color, Color? shadowColor, Color? surfaceTintColor, TextStyle? textStyle, BorderRadiusGeometry? borderRadius, ShapeBorder? shape, bool borderOnForeground = true, Clip clipBehavior = Clip.none, Duration animationDuration = kThemeChangeDuration,}) =>
    Material(child: this, key: key, type: type, elevation: elevation, color: color, shadowColor: shadowColor, surfaceTintColor: surfaceTintColor, textStyle: textStyle, borderRadius: borderRadius, shape: shape, borderOnForeground: borderOnForeground, clipBehavior: clipBehavior, animationDuration: animationDuration,);

  Widget selectionArea({Key? key, FocusNode? focusNode, TextSelectionControls? selectionControls, SelectableRegionContextMenuBuilder? contextMenuBuilder = _defaultContextMenuBuilder, TextMagnifierConfiguration? magnifierConfiguration, ValueChanged<SelectedContent?>? onSelectionChanged,}) =>
    SelectionArea(child: this, key: key, focusNode: focusNode, selectionControls: selectionControls, contextMenuBuilder: contextMenuBuilder, magnifierConfiguration: magnifierConfiguration, onSelectionChanged: onSelectionChanged,);

  Widget datePickerTheme({Key? key, required DatePickerThemeData data,}) =>
    DatePickerTheme(child: this, key: key, data: data,);

  Widget elevatedButtonTheme({Key? key, required ElevatedButtonThemeData data,}) =>
    ElevatedButtonTheme(child: this, key: key, data: data,);

  Widget materialBannerTheme({Key? key, MaterialBannerThemeData? data,}) =>
    MaterialBannerTheme(child: this, key: key, data: data,);

  Widget scaffoldMessenger({Key? key,}) =>
    ScaffoldMessenger(child: this, key: key,);

  Widget switchTheme({Key? key, required SwitchThemeData data,}) =>
    SwitchTheme(child: this, key: key, data: data,);

  Widget menuTheme({Key? key, required MenuThemeData data,}) =>
    MenuTheme(child: this, key: key, data: data,);

  Widget toggleButtonsTheme({Key? key, required ToggleButtonsThemeData data,}) =>
    ToggleButtonsTheme(child: this, key: key, data: data,);

  Widget textSelectionToolbarTextButton({Key? key, required EdgeInsets padding, VoidCallback? onPressed, AlignmentGeometry? alignment,}) =>
    TextSelectionToolbarTextButton(child: this, key: key, padding: padding, onPressed: onPressed, alignment: alignment,);

  Widget drawerTheme({Key? key, required DrawerThemeData data,}) =>
    DrawerTheme(child: this, key: key, data: data,);

  Widget actionIconTheme({Key? key, required ActionIconThemeData data,}) =>
    ActionIconTheme(child: this, key: key, data: data,);

  Widget navigationRailTheme({Key? key, required NavigationRailThemeData data,}) =>
    NavigationRailTheme(child: this, key: key, data: data,);

  Widget searchViewTheme({Key? key, required SearchViewThemeData data,}) =>
    SearchViewTheme(child: this, key: key, data: data,);

  Widget aboutListTile({Key? key, Widget? icon, String? applicationName, String? applicationVersion, Widget? applicationIcon, String? applicationLegalese, List<Widget>? aboutBoxChildren, bool? dense,}) =>
    AboutListTile(child: this, key: key, icon: icon, applicationName: applicationName, applicationVersion: applicationVersion, applicationIcon: applicationIcon, applicationLegalese: applicationLegalese, aboutBoxChildren: aboutBoxChildren, dense: dense,);

  Widget timePickerTheme({Key? key, required TimePickerThemeData data,}) =>
    TimePickerTheme(child: this, key: key, data: data,);

  Widget textSelectionTheme({Key? key, required TextSelectionThemeData data,}) =>
    TextSelectionTheme(child: this, key: key, data: data,);

  Widget dropdownMenuTheme({Key? key, required DropdownMenuThemeData data,}) =>
    DropdownMenuTheme(child: this, key: key, data: data,);

  Widget refreshIndicator({Key? key, double displacement = 40.0, double edgeOffset = 0.0, required m.RefreshCallback onRefresh, Color? color, Color? backgroundColor, ScrollNotificationPredicate notificationPredicate = defaultScrollNotificationPredicate, String? semanticsLabel, String? semanticsValue, double strokeWidth = RefreshProgressIndicator.defaultStrokeWidth, RefreshIndicatorTriggerMode triggerMode = RefreshIndicatorTriggerMode.onEdge, double elevation = 2.0,}) =>
    RefreshIndicator(child: this, key: key, displacement: displacement, edgeOffset: edgeOffset, onRefresh: onRefresh, color: color, backgroundColor: backgroundColor, notificationPredicate: notificationPredicate, semanticsLabel: semanticsLabel, semanticsValue: semanticsValue, strokeWidth: strokeWidth, triggerMode: triggerMode, elevation: elevation,);

  Widget refreshIndicatoradaptive({Key? key, double displacement = 40.0, double edgeOffset = 0.0, required m.RefreshCallback onRefresh, Color? color, Color? backgroundColor, ScrollNotificationPredicate notificationPredicate = defaultScrollNotificationPredicate, String? semanticsLabel, String? semanticsValue, double strokeWidth = RefreshProgressIndicator.defaultStrokeWidth, RefreshIndicatorTriggerMode triggerMode = RefreshIndicatorTriggerMode.onEdge, double elevation = 2.0,}) =>
    RefreshIndicator.adaptive(child: this, key: key, displacement: displacement, edgeOffset: edgeOffset, onRefresh: onRefresh, color: color, backgroundColor: backgroundColor, notificationPredicate: notificationPredicate, semanticsLabel: semanticsLabel, semanticsValue: semanticsValue, strokeWidth: strokeWidth, triggerMode: triggerMode, elevation: elevation,);

  Widget refreshIndicatornoSpinner({Key? key, required m.RefreshCallback onRefresh, ValueChanged<RefreshIndicatorStatus?>? onStatusChange, ScrollNotificationPredicate notificationPredicate = defaultScrollNotificationPredicate, String? semanticsLabel, String? semanticsValue, RefreshIndicatorTriggerMode triggerMode = RefreshIndicatorTriggerMode.onEdge, double elevation = 2.0,}) =>
    RefreshIndicator.noSpinner(child: this, key: key, onRefresh: onRefresh, onStatusChange: onStatusChange, notificationPredicate: notificationPredicate, semanticsLabel: semanticsLabel, semanticsValue: semanticsValue, triggerMode: triggerMode, elevation: elevation,);

  Widget tabBarTheme({Key? key, Decoration? indicator, Color? indicatorColor, TabBarIndicatorSize? indicatorSize, Color? dividerColor, double? dividerHeight, Color? labelColor, EdgeInsetsGeometry? labelPadding, TextStyle? labelStyle, Color? unselectedLabelColor, TextStyle? unselectedLabelStyle, WidgetStateProperty<Color?>? overlayColor, InteractiveInkFeatureFactory? splashFactory, WidgetStateProperty<MouseCursor?>? mouseCursor, TabAlignment? tabAlignment, TextScaler? textScaler, TabIndicatorAnimation? indicatorAnimation, TabBarThemeData? data,}) =>
    TabBarTheme(child: this, key: key, indicator: indicator, indicatorColor: indicatorColor, indicatorSize: indicatorSize, dividerColor: dividerColor, dividerHeight: dividerHeight, labelColor: labelColor, labelPadding: labelPadding, labelStyle: labelStyle, unselectedLabelColor: unselectedLabelColor, unselectedLabelStyle: unselectedLabelStyle, overlayColor: overlayColor, splashFactory: splashFactory, mouseCursor: mouseCursor, tabAlignment: tabAlignment, textScaler: textScaler, indicatorAnimation: indicatorAnimation, data: data,);

  Widget outlinedButtonTheme({Key? key, required OutlinedButtonThemeData data,}) =>
    OutlinedButtonTheme(child: this, key: key, data: data,);

  Widget listTileTheme({Key? key, ListTileThemeData? data, bool? dense, ShapeBorder? shape, ListTileStyle? style, Color? selectedColor, Color? iconColor, Color? textColor, EdgeInsetsGeometry? contentPadding, Color? tileColor, Color? selectedTileColor, bool? enableFeedback, MaterialStateProperty<MouseCursor?>? mouseCursor, double? horizontalTitleGap, double? minVerticalPadding, double? minLeadingWidth, ListTileControlAffinity? controlAffinity,}) =>
    ListTileTheme(child: this, key: key, data: data, dense: dense, shape: shape, style: style, selectedColor: selectedColor, iconColor: iconColor, textColor: textColor, contentPadding: contentPadding, tileColor: tileColor, selectedTileColor: selectedTileColor, enableFeedback: enableFeedback, mouseCursor: mouseCursor, horizontalTitleGap: horizontalTitleGap, minVerticalPadding: minVerticalPadding, minLeadingWidth: minLeadingWidth, controlAffinity: controlAffinity,);

  Widget circleAvatar({Key? key, Color? backgroundColor, ImageProvider? backgroundImage, ImageProvider? foregroundImage, ImageErrorListener? onBackgroundImageError, ImageErrorListener? onForegroundImageError, Color? foregroundColor, double? radius, double? minRadius, double? maxRadius,}) =>
    CircleAvatar(child: this, key: key, backgroundColor: backgroundColor, backgroundImage: backgroundImage, foregroundImage: foregroundImage, onBackgroundImageError: onBackgroundImageError, onForegroundImageError: onForegroundImageError, foregroundColor: foregroundColor, radius: radius, minRadius: minRadius, maxRadius: maxRadius,);

  Widget ink({Key? key, EdgeInsetsGeometry? padding, Color? color, Decoration? decoration, double? width, double? height,}) =>
    Ink(child: this, key: key, padding: padding, color: color, decoration: decoration, width: width, height: height,);

  Widget inkimage({Key? key, EdgeInsetsGeometry? padding, required ImageProvider image, ImageErrorListener? onImageError, ColorFilter? colorFilter, BoxFit? fit, AlignmentGeometry alignment = Alignment.center, Rect? centerSlice, ImageRepeat repeat = ImageRepeat.noRepeat, bool matchTextDirection = false, double? width, double? height,}) =>
    Ink.image(child: this, key: key, padding: padding, image: image, onImageError: onImageError, colorFilter: colorFilter, fit: fit, alignment: alignment, centerSlice: centerSlice, repeat: repeat, matchTextDirection: matchTextDirection, width: width, height: height,);

  Widget badge({Key? key, Color? backgroundColor, Color? textColor, double? smallSize, double? largeSize, TextStyle? textStyle, EdgeInsetsGeometry? padding, AlignmentGeometry? alignment, Offset? offset, Widget? label, bool isLabelVisible = true,}) =>
    Badge(child: this, key: key, backgroundColor: backgroundColor, textColor: textColor, smallSize: smallSize, largeSize: largeSize, textStyle: textStyle, padding: padding, alignment: alignment, offset: offset, label: label, isLabelVisible: isLabelVisible,);

  Widget badgecount({Key? key, Color? backgroundColor, Color? textColor, double? smallSize, double? largeSize, TextStyle? textStyle, EdgeInsetsGeometry? padding, AlignmentGeometry? alignment, Offset? offset, required int count, bool isLabelVisible = true,}) =>
    Badge.count(child: this, key: key, backgroundColor: backgroundColor, textColor: textColor, smallSize: smallSize, largeSize: largeSize, textStyle: textStyle, padding: padding, alignment: alignment, offset: offset, count: count, isLabelVisible: isLabelVisible,);

  Widget inputDecorator({Key? key, required InputDecoration decoration, TextStyle? baseStyle, TextAlign? textAlign, TextAlignVertical? textAlignVertical, bool isFocused = false, bool isHovering = false, bool expands = false, bool isEmpty = false,}) =>
    InputDecorator(child: this, key: key, decoration: decoration, baseStyle: baseStyle, textAlign: textAlign, textAlignVertical: textAlignVertical, isFocused: isFocused, isHovering: isHovering, expands: expands, isEmpty: isEmpty,);

  Widget badgeTheme({Key? key, required BadgeThemeData data,}) =>
    BadgeTheme(child: this, key: key, data: data,);

  Widget menuAnchor({Key? key, MenuController? controller, FocusNode? childFocusNode, MenuStyle? style, Offset? alignmentOffset = Offset.zero, LayerLink? layerLink, Clip clipBehavior = Clip.hardEdge, bool anchorTapClosesMenu = false, bool consumeOutsideTap = false, VoidCallback? onOpen, VoidCallback? onClose, bool crossAxisUnconstrained = true, required List<Widget> menuChildren, MenuAnchorChildBuilder? builder,}) =>
    MenuAnchor(child: this, key: key, controller: controller, childFocusNode: childFocusNode, style: style, alignmentOffset: alignmentOffset, layerLink: layerLink, clipBehavior: clipBehavior, anchorTapClosesMenu: anchorTapClosesMenu, consumeOutsideTap: consumeOutsideTap, onOpen: onOpen, onClose: onClose, crossAxisUnconstrained: crossAxisUnconstrained, menuChildren: menuChildren, builder: builder,);

  Widget menuItemButton({Key? key, VoidCallback? onPressed, ValueChanged<bool>? onHover, bool requestFocusOnHover = true, ValueChanged<bool>? onFocusChange, FocusNode? focusNode, bool autofocus = false, MenuSerializableShortcut? shortcut, String? semanticsLabel, ButtonStyle? style, MaterialStatesController? statesController, Clip clipBehavior = Clip.none, Widget? leadingIcon, Widget? trailingIcon, bool closeOnActivate = true, Axis overflowAxis = Axis.horizontal,}) =>
    MenuItemButton(child: this, key: key, onPressed: onPressed, onHover: onHover, requestFocusOnHover: requestFocusOnHover, onFocusChange: onFocusChange, focusNode: focusNode, autofocus: autofocus, shortcut: shortcut, semanticsLabel: semanticsLabel, style: style, statesController: statesController, clipBehavior: clipBehavior, leadingIcon: leadingIcon, trailingIcon: trailingIcon, closeOnActivate: closeOnActivate, overflowAxis: overflowAxis,);

  Widget checkboxMenuButton({Key? key, required bool value, bool tristate = false, bool isError = false, required ValueChanged<bool?> onChanged, ValueChanged<bool>? onHover, ValueChanged<bool>? onFocusChange, FocusNode? focusNode, MenuSerializableShortcut? shortcut, ButtonStyle? style, MaterialStatesController? statesController, Clip clipBehavior = Clip.none, Widget? trailingIcon, bool closeOnActivate = true,}) =>
    CheckboxMenuButton(child: this, key: key, value: value, tristate: tristate, isError: isError, onChanged: onChanged, onHover: onHover, onFocusChange: onFocusChange, focusNode: focusNode, shortcut: shortcut, style: style, statesController: statesController, clipBehavior: clipBehavior, trailingIcon: trailingIcon, closeOnActivate: closeOnActivate,);

  Widget radioMenuButton<T>({Key? key, required T value, required T groupValue, required ValueChanged<T?> onChanged, bool toggleable = false, ValueChanged<bool>? onHover, ValueChanged<bool>? onFocusChange, FocusNode? focusNode, MenuSerializableShortcut? shortcut, ButtonStyle? style, MaterialStatesController? statesController, Clip clipBehavior = Clip.none, Widget? trailingIcon, bool closeOnActivate = true,}) =>
    RadioMenuButton(child: this, key: key, value: value, groupValue: groupValue, onChanged: onChanged, toggleable: toggleable, onHover: onHover, onFocusChange: onFocusChange, focusNode: focusNode, shortcut: shortcut, style: style, statesController: statesController, clipBehavior: clipBehavior, trailingIcon: trailingIcon, closeOnActivate: closeOnActivate,);

  Widget submenuButton({Key? key, ValueChanged<bool>? onHover, ValueChanged<bool>? onFocusChange, VoidCallback? onOpen, VoidCallback? onClose, MenuController? controller, ButtonStyle? style, MenuStyle? menuStyle, Offset? alignmentOffset, Clip clipBehavior = Clip.hardEdge, FocusNode? focusNode, MaterialStatesController? statesController, Widget? leadingIcon, Widget? trailingIcon, required List<Widget> menuChildren,}) =>
    SubmenuButton(child: this, key: key, onHover: onHover, onFocusChange: onFocusChange, onOpen: onOpen, onClose: onClose, controller: controller, style: style, menuStyle: menuStyle, alignmentOffset: alignmentOffset, clipBehavior: clipBehavior, focusNode: focusNode, statesController: statesController, leadingIcon: leadingIcon, trailingIcon: trailingIcon, menuChildren: menuChildren,);

  Widget menuAcceleratorCallbackBinding({Key? key, VoidCallback? onInvoke, bool hasSubmenu = false,}) =>
    MenuAcceleratorCallbackBinding(child: this, key: key, onInvoke: onInvoke, hasSubmenu: hasSubmenu,);

  Widget card({Key? key, Color? color, Color? shadowColor, Color? surfaceTintColor, double? elevation, ShapeBorder? shape, bool borderOnForeground = true, EdgeInsetsGeometry? margin, Clip? clipBehavior, bool semanticContainer = true,}) =>
    Card(child: this, key: key, color: color, shadowColor: shadowColor, surfaceTintColor: surfaceTintColor, elevation: elevation, shape: shape, borderOnForeground: borderOnForeground, margin: margin, clipBehavior: clipBehavior, semanticContainer: semanticContainer,);

  Widget cardfilled({Key? key, Color? color, Color? shadowColor, Color? surfaceTintColor, double? elevation, ShapeBorder? shape, bool borderOnForeground = true, EdgeInsetsGeometry? margin, Clip? clipBehavior, bool semanticContainer = true,}) =>
    Card.filled(child: this, key: key, color: color, shadowColor: shadowColor, surfaceTintColor: surfaceTintColor, elevation: elevation, shape: shape, borderOnForeground: borderOnForeground, margin: margin, clipBehavior: clipBehavior, semanticContainer: semanticContainer,);

  Widget cardoutlined({Key? key, Color? color, Color? shadowColor, Color? surfaceTintColor, double? elevation, ShapeBorder? shape, bool borderOnForeground = true, EdgeInsetsGeometry? margin, Clip? clipBehavior, bool semanticContainer = true,}) =>
    Card.outlined(child: this, key: key, color: color, shadowColor: shadowColor, surfaceTintColor: surfaceTintColor, elevation: elevation, shape: shape, borderOnForeground: borderOnForeground, margin: margin, clipBehavior: clipBehavior, semanticContainer: semanticContainer,);

  Widget rawMaterialButton({Key? key, required VoidCallback onPressed, VoidCallback? onLongPress, ValueChanged<bool>? onHighlightChanged, MouseCursor? mouseCursor, TextStyle? textStyle, Color? fillColor, Color? focusColor, Color? hoverColor, Color? highlightColor, Color? splashColor, double elevation = 2.0, double focusElevation = 4.0, double hoverElevation = 4.0, double highlightElevation = 8.0, double disabledElevation = 0.0, EdgeInsetsGeometry padding = EdgeInsets.zero, VisualDensity visualDensity = VisualDensity.standard, BoxConstraints constraints = const BoxConstraints(minWidth: 88.0, minHeight: 36.0), ShapeBorder shape = const RoundedRectangleBorder(), Duration animationDuration = kThemeChangeDuration, Clip clipBehavior = Clip.none, FocusNode? focusNode, bool autofocus = false, MaterialTapTargetSize? materialTapTargetSize, bool enableFeedback = true,}) =>
    RawMaterialButton(child: this, key: key, onPressed: onPressed, onLongPress: onLongPress, onHighlightChanged: onHighlightChanged, mouseCursor: mouseCursor, textStyle: textStyle, fillColor: fillColor, focusColor: focusColor, hoverColor: hoverColor, highlightColor: highlightColor, splashColor: splashColor, elevation: elevation, focusElevation: focusElevation, hoverElevation: hoverElevation, highlightElevation: highlightElevation, disabledElevation: disabledElevation, padding: padding, visualDensity: visualDensity, constraints: constraints, shape: shape, animationDuration: animationDuration, clipBehavior: clipBehavior, focusNode: focusNode, autofocus: autofocus, materialTapTargetSize: materialTapTargetSize, enableFeedback: enableFeedback,);

  Widget popupMenuTheme({Key? key, required PopupMenuThemeData data,}) =>
    PopupMenuTheme(child: this, key: key, data: data,);

  Widget tableRowInkWell({GestureTapCallback? onTap, GestureTapCallback? onDoubleTap, GestureLongPressCallback? onLongPress, ValueChanged<bool>? onHighlightChanged, GestureTapCallback? onSecondaryTap, GestureTapDownCallback? onSecondaryTapDown, MaterialStateProperty<Color?>? overlayColor, MouseCursor? mouseCursor,}) =>
    TableRowInkWell(child: this, onTap: onTap, onDoubleTap: onDoubleTap, onLongPress: onLongPress, onHighlightChanged: onHighlightChanged, onSecondaryTap: onSecondaryTap, onSecondaryTapDown: onSecondaryTapDown, overlayColor: overlayColor, mouseCursor: mouseCursor,);

  Widget defaultTabController({Key? key, required int length, int initialIndex = 0, Duration? animationDuration,}) =>
    DefaultTabController(child: this, key: key, length: length, initialIndex: initialIndex, animationDuration: animationDuration,);

  Widget tooltipTheme({Key? key, required TooltipThemeData data,}) =>
    TooltipTheme(child: this, key: key, data: data,);

  Widget menuButtonTheme({Key? key, required MenuButtonThemeData data,}) =>
    MenuButtonTheme(child: this, key: key, data: data,);

  Widget textButton({required VoidCallback onPressed, VoidCallback? onLongPress, ValueChanged<bool>? onHover, ValueChanged<bool>? onFocusChange, ButtonStyle? style, FocusNode? focusNode, bool autofocus = false, Clip? clipBehavior, MaterialStatesController? statesController, bool? isSemanticButton = true, IconAlignment iconAlignment = IconAlignment.start,}) =>
    TextButton(child: this, onPressed: onPressed, onLongPress: onLongPress, onHover: onHover, onFocusChange: onFocusChange, style: style, focusNode: focusNode, autofocus: autofocus, clipBehavior: clipBehavior, statesController: statesController, isSemanticButton: isSemanticButton, iconAlignment: iconAlignment,);

  Widget dialog({Key? key, Color? backgroundColor, double? elevation, Color? shadowColor, Color? surfaceTintColor, Duration insetAnimationDuration = const Duration(milliseconds: 100), Curve insetAnimationCurve = Curves.decelerate, EdgeInsets? insetPadding, Clip? clipBehavior, ShapeBorder? shape, AlignmentGeometry? alignment,}) =>
    Dialog(child: this, key: key, backgroundColor: backgroundColor, elevation: elevation, shadowColor: shadowColor, surfaceTintColor: surfaceTintColor, insetAnimationDuration: insetAnimationDuration, insetAnimationCurve: insetAnimationCurve, insetPadding: insetPadding, clipBehavior: clipBehavior, shape: shape, alignment: alignment,);

  Widget dialogfullscreen({Key? key, Color? backgroundColor, Duration insetAnimationDuration = Duration.zero, Curve insetAnimationCurve = Curves.decelerate,}) =>
    Dialog.fullscreen(child: this, key: key, backgroundColor: backgroundColor, insetAnimationDuration: insetAnimationDuration, insetAnimationCurve: insetAnimationCurve,);

  Widget simpleDialogOption({Key? key, VoidCallback? onPressed, EdgeInsets? padding,}) =>
    SimpleDialogOption(child: this, key: key, onPressed: onPressed, padding: padding,);

  Widget inkResponse({Key? key, GestureTapCallback? onTap, GestureTapDownCallback? onTapDown, GestureTapUpCallback? onTapUp, GestureTapCallback? onTapCancel, GestureTapCallback? onDoubleTap, GestureLongPressCallback? onLongPress, GestureTapCallback? onSecondaryTap, GestureTapUpCallback? onSecondaryTapUp, GestureTapDownCallback? onSecondaryTapDown, GestureTapCallback? onSecondaryTapCancel, ValueChanged<bool>? onHighlightChanged, ValueChanged<bool>? onHover, MouseCursor? mouseCursor, bool containedInkWell = false, BoxShape highlightShape = BoxShape.circle, double? radius, BorderRadius? borderRadius, ShapeBorder? customBorder, Color? focusColor, Color? hoverColor, Color? highlightColor, MaterialStateProperty<Color?>? overlayColor, Color? splashColor, InteractiveInkFeatureFactory? splashFactory, bool enableFeedback = true, bool excludeFromSemantics = false, FocusNode? focusNode, bool canRequestFocus = true, ValueChanged<bool>? onFocusChange, bool autofocus = false, MaterialStatesController? statesController, Duration? hoverDuration,}) =>
    InkResponse(child: this, key: key, onTap: onTap, onTapDown: onTapDown, onTapUp: onTapUp, onTapCancel: onTapCancel, onDoubleTap: onDoubleTap, onLongPress: onLongPress, onSecondaryTap: onSecondaryTap, onSecondaryTapUp: onSecondaryTapUp, onSecondaryTapDown: onSecondaryTapDown, onSecondaryTapCancel: onSecondaryTapCancel, onHighlightChanged: onHighlightChanged, onHover: onHover, mouseCursor: mouseCursor, containedInkWell: containedInkWell, highlightShape: highlightShape, radius: radius, borderRadius: borderRadius, customBorder: customBorder, focusColor: focusColor, hoverColor: hoverColor, highlightColor: highlightColor, overlayColor: overlayColor, splashColor: splashColor, splashFactory: splashFactory, enableFeedback: enableFeedback, excludeFromSemantics: excludeFromSemantics, focusNode: focusNode, canRequestFocus: canRequestFocus, onFocusChange: onFocusChange, autofocus: autofocus, statesController: statesController, hoverDuration: hoverDuration,);

  Widget inkWell({GestureTapCallback? onTap, GestureTapCallback? onDoubleTap, GestureLongPressCallback? onLongPress, GestureTapDownCallback? onTapDown, GestureTapUpCallback? onTapUp, GestureTapCallback? onTapCancel, GestureTapCallback? onSecondaryTap, GestureTapUpCallback? onSecondaryTapUp, GestureTapDownCallback? onSecondaryTapDown, GestureTapCallback? onSecondaryTapCancel, ValueChanged<bool>? onHighlightChanged, ValueChanged<bool>? onHover, MouseCursor? mouseCursor, Color? focusColor, Color? hoverColor, Color? highlightColor, MaterialStateProperty<Color?>? overlayColor, Color? splashColor, InteractiveInkFeatureFactory? splashFactory, double? radius, BorderRadius? borderRadius, ShapeBorder? customBorder, bool? enableFeedback = true, bool excludeFromSemantics = false, FocusNode? focusNode, bool canRequestFocus = true, ValueChanged<bool>? onFocusChange, bool autofocus = false, MaterialStatesController? statesController, Duration? hoverDuration,}) =>
    InkWell(child: this, onTap: onTap, onDoubleTap: onDoubleTap, onLongPress: onLongPress, onTapDown: onTapDown, onTapUp: onTapUp, onTapCancel: onTapCancel, onSecondaryTap: onSecondaryTap, onSecondaryTapUp: onSecondaryTapUp, onSecondaryTapDown: onSecondaryTapDown, onSecondaryTapCancel: onSecondaryTapCancel, onHighlightChanged: onHighlightChanged, onHover: onHover, mouseCursor: mouseCursor, focusColor: focusColor, hoverColor: hoverColor, highlightColor: highlightColor, overlayColor: overlayColor, splashColor: splashColor, splashFactory: splashFactory, radius: radius, borderRadius: borderRadius, customBorder: customBorder, enableFeedback: enableFeedback, excludeFromSemantics: excludeFromSemantics, focusNode: focusNode, canRequestFocus: canRequestFocus, onFocusChange: onFocusChange, autofocus: autofocus, statesController: statesController, hoverDuration: hoverDuration,);

  Widget radioTheme({Key? key, required RadioThemeData data,}) =>
    RadioTheme(child: this, key: key, data: data,);

  Widget tab({Key? key, String? text, Widget? icon, EdgeInsetsGeometry? iconMargin, double? height,}) =>
    Tab(child: this, key: key, text: text, icon: icon, iconMargin: iconMargin, height: height,);

  Widget bottomNavigationBarTheme({Key? key, required BottomNavigationBarThemeData data,}) =>
    BottomNavigationBarTheme(child: this, key: key, data: data,);

  Widget floatingActionButton({Key? key, String? tooltip, Color? foregroundColor, Color? backgroundColor, Color? focusColor, Color? hoverColor, Color? splashColor, Object? heroTag = const _DefaultHeroTag(), double? elevation, double? focusElevation, double? hoverElevation, double? highlightElevation, double? disabledElevation, required VoidCallback onPressed, MouseCursor? mouseCursor, bool mini = false, ShapeBorder? shape, Clip clipBehavior = Clip.none, FocusNode? focusNode, bool autofocus = false, MaterialTapTargetSize? materialTapTargetSize, bool isExtended = false, bool? enableFeedback,}) =>
    FloatingActionButton(child: this, key: key, tooltip: tooltip, foregroundColor: foregroundColor, backgroundColor: backgroundColor, focusColor: focusColor, hoverColor: hoverColor, splashColor: splashColor, heroTag: heroTag, elevation: elevation, focusElevation: focusElevation, hoverElevation: hoverElevation, highlightElevation: highlightElevation, disabledElevation: disabledElevation, onPressed: onPressed, mouseCursor: mouseCursor, mini: mini, shape: shape, clipBehavior: clipBehavior, focusNode: focusNode, autofocus: autofocus, materialTapTargetSize: materialTapTargetSize, isExtended: isExtended, enableFeedback: enableFeedback,);

  Widget floatingActionButtonsmall({Key? key, String? tooltip, Color? foregroundColor, Color? backgroundColor, Color? focusColor, Color? hoverColor, Color? splashColor, Object? heroTag = const _DefaultHeroTag(), double? elevation, double? focusElevation, double? hoverElevation, double? highlightElevation, double? disabledElevation, required VoidCallback onPressed, MouseCursor? mouseCursor, ShapeBorder? shape, Clip clipBehavior = Clip.none, FocusNode? focusNode, bool autofocus = false, MaterialTapTargetSize? materialTapTargetSize, bool? enableFeedback,}) =>
    FloatingActionButton.small(child: this, key: key, tooltip: tooltip, foregroundColor: foregroundColor, backgroundColor: backgroundColor, focusColor: focusColor, hoverColor: hoverColor, splashColor: splashColor, heroTag: heroTag, elevation: elevation, focusElevation: focusElevation, hoverElevation: hoverElevation, highlightElevation: highlightElevation, disabledElevation: disabledElevation, onPressed: onPressed, mouseCursor: mouseCursor, shape: shape, clipBehavior: clipBehavior, focusNode: focusNode, autofocus: autofocus, materialTapTargetSize: materialTapTargetSize, enableFeedback: enableFeedback,);

  Widget floatingActionButtonlarge({Key? key, String? tooltip, Color? foregroundColor, Color? backgroundColor, Color? focusColor, Color? hoverColor, Color? splashColor, Object? heroTag = const _DefaultHeroTag(), double? elevation, double? focusElevation, double? hoverElevation, double? highlightElevation, double? disabledElevation, required VoidCallback onPressed, MouseCursor? mouseCursor, ShapeBorder? shape, Clip clipBehavior = Clip.none, FocusNode? focusNode, bool autofocus = false, MaterialTapTargetSize? materialTapTargetSize, bool? enableFeedback,}) =>
    FloatingActionButton.large(child: this, key: key, tooltip: tooltip, foregroundColor: foregroundColor, backgroundColor: backgroundColor, focusColor: focusColor, hoverColor: hoverColor, splashColor: splashColor, heroTag: heroTag, elevation: elevation, focusElevation: focusElevation, hoverElevation: hoverElevation, highlightElevation: highlightElevation, disabledElevation: disabledElevation, onPressed: onPressed, mouseCursor: mouseCursor, shape: shape, clipBehavior: clipBehavior, focusNode: focusNode, autofocus: autofocus, materialTapTargetSize: materialTapTargetSize, enableFeedback: enableFeedback,);

  Widget filledButton({required VoidCallback onPressed, VoidCallback? onLongPress, ValueChanged<bool>? onHover, ValueChanged<bool>? onFocusChange, ButtonStyle? style, FocusNode? focusNode, bool autofocus = false, Clip? clipBehavior = Clip.none, MaterialStatesController? statesController, IconAlignment iconAlignment = IconAlignment.start,}) =>
    FilledButton(child: this, onPressed: onPressed, onLongPress: onLongPress, onHover: onHover, onFocusChange: onFocusChange, style: style, focusNode: focusNode, autofocus: autofocus, clipBehavior: clipBehavior, statesController: statesController, iconAlignment: iconAlignment,);

  Widget filledButtontonal({required VoidCallback onPressed, VoidCallback? onLongPress, ValueChanged<bool>? onHover, ValueChanged<bool>? onFocusChange, ButtonStyle? style, FocusNode? focusNode, bool autofocus = false, Clip? clipBehavior = Clip.none, MaterialStatesController? statesController,}) =>
    FilledButton.tonal(child: this, onPressed: onPressed, onLongPress: onLongPress, onHover: onHover, onFocusChange: onFocusChange, style: style, focusNode: focusNode, autofocus: autofocus, clipBehavior: clipBehavior, statesController: statesController,);

  Widget tooltipVisibility({Key? key, required bool visible,}) =>
    TooltipVisibility(child: this, key: key, visible: visible,);

  Widget checkboxTheme({Key? key, required CheckboxThemeData data,}) =>
    CheckboxTheme(child: this, key: key, data: data,);

  Widget scrollbarTheme({Key? key, required ScrollbarThemeData data,}) =>
    ScrollbarTheme(child: this, key: key, data: data,);

  Widget popupMenuItem<T>({T? value, VoidCallback? onTap, bool enabled = true, double height = kMinInteractiveDimension, EdgeInsets? padding, TextStyle? textStyle, MaterialStateProperty<TextStyle?>? labelTextStyle, MouseCursor? mouseCursor,}) =>
    PopupMenuItem(child: this, value: value, onTap: onTap, enabled: enabled, height: height, padding: padding, textStyle: textStyle, labelTextStyle: labelTextStyle, mouseCursor: mouseCursor,);

  Widget checkedPopupMenuItem<T>({T? value, bool checked = false, bool enabled = true, EdgeInsets? padding, double height = kMinInteractiveDimension, MaterialStateProperty<TextStyle?>? labelTextStyle, MouseCursor? mouseCursor, VoidCallback? onTap,}) =>
    CheckedPopupMenuItem(child: this, value: value, checked: checked, enabled: enabled, padding: padding, height: height, labelTextStyle: labelTextStyle, mouseCursor: mouseCursor, onTap: onTap,);

  Widget popupMenuButton<T>({Key? key, required PopupMenuItemBuilder<T> itemBuilder, T? initialValue, VoidCallback? onOpened, PopupMenuItemSelected<T>? onSelected, PopupMenuCanceled? onCanceled, String? tooltip, double? elevation, Color? shadowColor, Color? surfaceTintColor, EdgeInsetsGeometry padding = const EdgeInsets.all(8.0), EdgeInsetsGeometry? menuPadding, BorderRadius? borderRadius, double? splashRadius, Widget? icon, double? iconSize, Offset offset = Offset.zero, bool enabled = true, ShapeBorder? shape, Color? color, Color? iconColor, bool? enableFeedback, BoxConstraints? constraints, PopupMenuPosition? position, Clip clipBehavior = Clip.none, bool useRootNavigator = false, AnimationStyle? popUpAnimationStyle, RouteSettings? routeSettings, ButtonStyle? style, bool? requestFocus,}) =>
    PopupMenuButton(child: this, key: key, itemBuilder: itemBuilder, initialValue: initialValue, onOpened: onOpened, onSelected: onSelected, onCanceled: onCanceled, tooltip: tooltip, elevation: elevation, shadowColor: shadowColor, surfaceTintColor: surfaceTintColor, padding: padding, menuPadding: menuPadding, borderRadius: borderRadius, splashRadius: splashRadius, icon: icon, iconSize: iconSize, offset: offset, enabled: enabled, shape: shape, color: color, iconColor: iconColor, enableFeedback: enableFeedback, constraints: constraints, position: position, clipBehavior: clipBehavior, useRootNavigator: useRootNavigator, popUpAnimationStyle: popUpAnimationStyle, routeSettings: routeSettings, style: style, requestFocus: requestFocus,);

  Widget bottomAppBar({Key? key, Color? color, double? elevation, NotchedShape? shape, Clip clipBehavior = Clip.none, double notchMargin = 4.0, EdgeInsetsGeometry? padding, Color? surfaceTintColor, Color? shadowColor, double? height,}) =>
    BottomAppBar(child: this, key: key, color: color, elevation: elevation, shape: shape, clipBehavior: clipBehavior, notchMargin: notchMargin, padding: padding, surfaceTintColor: surfaceTintColor, shadowColor: shadowColor, height: height,);

  Widget navigationDrawerTheme({Key? key, required NavigationDrawerThemeData data,}) =>
    NavigationDrawerTheme(child: this, key: key, data: data,);

  Widget filledButtonTheme({Key? key, required FilledButtonThemeData data,}) =>
    FilledButtonTheme(child: this, key: key, data: data,);

  Widget dialogTheme({Key? key, Color? backgroundColor, double? elevation, Color? shadowColor, Color? surfaceTintColor, ShapeBorder? shape, AlignmentGeometry? alignment, Color? iconColor, TextStyle? titleTextStyle, TextStyle? contentTextStyle, EdgeInsetsGeometry? actionsPadding, Color? barrierColor, EdgeInsets? insetPadding, Clip? clipBehavior, DialogThemeData? data,}) =>
    DialogTheme(child: this, key: key, backgroundColor: backgroundColor, elevation: elevation, shadowColor: shadowColor, surfaceTintColor: surfaceTintColor, shape: shape, alignment: alignment, iconColor: iconColor, titleTextStyle: titleTextStyle, contentTextStyle: contentTextStyle, actionsPadding: actionsPadding, barrierColor: barrierColor, insetPadding: insetPadding, clipBehavior: clipBehavior, data: data,);

  Widget segmentedButtonTheme({Key? key, required SegmentedButtonThemeData data,}) =>
    SegmentedButtonTheme(child: this, key: key, data: data,);

  Widget cardTheme({Key? key, Clip? clipBehavior, Color? color, Color? surfaceTintColor, Color? shadowColor, double? elevation, EdgeInsetsGeometry? margin, ShapeBorder? shape, CardThemeData? data,}) =>
    CardTheme(child: this, key: key, clipBehavior: clipBehavior, color: color, surfaceTintColor: surfaceTintColor, shadowColor: shadowColor, elevation: elevation, margin: margin, shape: shape, data: data,);

  Widget tooltip({Key? key, String? message, InlineSpan? richMessage, double? height, EdgeInsetsGeometry? padding, EdgeInsetsGeometry? margin, double? verticalOffset, bool? preferBelow, bool? excludeFromSemantics, Decoration? decoration, TextStyle? textStyle, TextAlign? textAlign, Duration? waitDuration, Duration? showDuration, Duration? exitDuration, bool enableTapToDismiss = true, TooltipTriggerMode? triggerMode, bool? enableFeedback, TooltipTriggeredCallback? onTriggered,}) =>
    Tooltip(child: this, key: key, message: message, richMessage: richMessage, height: height, padding: padding, margin: margin, verticalOffset: verticalOffset, preferBelow: preferBelow, excludeFromSemantics: excludeFromSemantics, decoration: decoration, textStyle: textStyle, textAlign: textAlign, waitDuration: waitDuration, showDuration: showDuration, exitDuration: exitDuration, enableTapToDismiss: enableTapToDismiss, triggerMode: triggerMode, enableFeedback: enableFeedback, onTriggered: onTriggered,);

  Widget elevatedButton({required VoidCallback onPressed, VoidCallback? onLongPress, ValueChanged<bool>? onHover, ValueChanged<bool>? onFocusChange, ButtonStyle? style, FocusNode? focusNode, bool autofocus = false, Clip? clipBehavior, MaterialStatesController? statesController, IconAlignment iconAlignment = IconAlignment.start,}) =>
    ElevatedButton(child: this, onPressed: onPressed, onLongPress: onLongPress, onHover: onHover, onFocusChange: onFocusChange, style: style, focusNode: focusNode, autofocus: autofocus, clipBehavior: clipBehavior, statesController: statesController, iconAlignment: iconAlignment,);

  Widget dropdownMenuItem<T>({VoidCallback? onTap, T? value, bool enabled = true, AlignmentGeometry alignment = AlignmentDirectional.centerStart,}) =>
    DropdownMenuItem(child: this, onTap: onTap, value: value, enabled: enabled, alignment: alignment,);

  Widget dropdownButtonHideUnderline({Key? key,}) =>
    DropdownButtonHideUnderline(child: this, key: key,);

  Widget buttonTheme({Key? key, ButtonTextTheme textTheme = ButtonTextTheme.normal, ButtonBarLayoutBehavior layoutBehavior = ButtonBarLayoutBehavior.padded, double minWidth = 88.0, double height = 36.0, EdgeInsetsGeometry? padding, ShapeBorder? shape, bool alignedDropdown = false, Color? buttonColor, Color? disabledColor, Color? focusColor, Color? hoverColor, Color? highlightColor, Color? splashColor, ColorScheme? colorScheme, MaterialTapTargetSize? materialTapTargetSize,}) =>
    ButtonTheme(child: this, key: key, textTheme: textTheme, layoutBehavior: layoutBehavior, minWidth: minWidth, height: height, padding: padding, shape: shape, alignedDropdown: alignedDropdown, buttonColor: buttonColor, disabledColor: disabledColor, focusColor: focusColor, hoverColor: hoverColor, highlightColor: highlightColor, splashColor: splashColor, colorScheme: colorScheme, materialTapTargetSize: materialTapTargetSize,);

  Widget buttonThemefromButtonThemeData({Key? key, required ButtonThemeData data,}) =>
    ButtonTheme.fromButtonThemeData(child: this, key: key, data: data,);

  Widget dividerTheme({Key? key, required DividerThemeData data,}) =>
    DividerTheme(child: this, key: key, data: data,);

  Widget dataTableTheme({Key? key, required DataTableThemeData data,}) =>
    DataTableTheme(child: this, key: key, data: data,);

  Widget outlinedButton({required VoidCallback onPressed, VoidCallback? onLongPress, ValueChanged<bool>? onHover, ValueChanged<bool>? onFocusChange, ButtonStyle? style, FocusNode? focusNode, bool autofocus = false, Clip? clipBehavior, MaterialStatesController? statesController, IconAlignment iconAlignment = IconAlignment.start,}) =>
    OutlinedButton(child: this, onPressed: onPressed, onLongPress: onLongPress, onHover: onHover, onFocusChange: onFocusChange, style: style, focusNode: focusNode, autofocus: autofocus, clipBehavior: clipBehavior, statesController: statesController, iconAlignment: iconAlignment,);

  Widget sliderTheme({Key? key, required SliderThemeData data,}) =>
    SliderTheme(child: this, key: key, data: data,);

  Widget chipTheme({Key? key, required ChipThemeData data,}) =>
    ChipTheme(child: this, key: key, data: data,);

  Widget iconButtonTheme({Key? key, required IconButtonThemeData data,}) =>
    IconButtonTheme(child: this, key: key, data: data,);

  Widget drawer({Key? key, Color? backgroundColor, double? elevation, Color? shadowColor, Color? surfaceTintColor, ShapeBorder? shape, double? width, String? semanticLabel, Clip? clipBehavior,}) =>
    Drawer(child: this, key: key, backgroundColor: backgroundColor, elevation: elevation, shadowColor: shadowColor, surfaceTintColor: surfaceTintColor, shape: shape, width: width, semanticLabel: semanticLabel, clipBehavior: clipBehavior,);

  Widget drawerController({GlobalKey? key, required DrawerAlignment alignment, bool isDrawerOpen = false, DrawerCallback? drawerCallback, DragStartBehavior dragStartBehavior = DragStartBehavior.start, Color? scrimColor, double? edgeDragWidth, bool enableOpenDragGesture = true,}) =>
    DrawerController(child: this, key: key, alignment: alignment, isDrawerOpen: isDrawerOpen, drawerCallback: drawerCallback, dragStartBehavior: dragStartBehavior, scrimColor: scrimColor, edgeDragWidth: edgeDragWidth, enableOpenDragGesture: enableOpenDragGesture,);

  Widget expansionTileTheme({Key? key, required ExpansionTileThemeData data,}) =>
    ExpansionTileTheme(child: this, key: key, data: data,);

  Widget flexibleSpaceBarSettings({Key? key, required double toolbarOpacity, required double minExtent, required double maxExtent, required double currentExtent, bool? isScrolledUnder, bool? hasLeading,}) =>
    FlexibleSpaceBarSettings(child: this, key: key, toolbarOpacity: toolbarOpacity, minExtent: minExtent, maxExtent: maxExtent, currentExtent: currentExtent, isScrolledUnder: isScrolledUnder, hasLeading: hasLeading,);

  Widget navigationBarTheme({Key? key, required NavigationBarThemeData data,}) =>
    NavigationBarTheme(child: this, key: key, data: data,);

  Widget scrollbar({Key? key, ScrollController? controller, bool? thumbVisibility, bool? trackVisibility, double? thickness, Radius? radius, ScrollNotificationPredicate? notificationPredicate, bool? interactive, ScrollbarOrientation? scrollbarOrientation,}) =>
    Scrollbar(child: this, key: key, controller: controller, thumbVisibility: thumbVisibility, trackVisibility: trackVisibility, thickness: thickness, radius: radius, notificationPredicate: notificationPredicate, interactive: interactive, scrollbarOrientation: scrollbarOrientation,);

  Widget searchBarTheme({Key? key, required SearchBarThemeData data,}) =>
    SearchBarTheme(child: this, key: key, data: data,);

  Widget menuBarTheme({Key? key, required MenuBarThemeData data,}) =>
    MenuBarTheme(child: this, key: key, data: data,);

  Widget buttonBarTheme({Key? key, required ButtonBarThemeData data,}) =>
    ButtonBarTheme(child: this, key: key, data: data,);

  Widget theme({Key? key, required ThemeData data,}) =>
    Theme(child: this, key: key, data: data,);

  Widget animatedTheme({Key? key, required ThemeData data, Curve curve = Curves.linear, Duration duration = kThemeAnimationDuration, VoidCallback? onEnd,}) =>
    AnimatedTheme(child: this, key: key, data: data, curve: curve, duration: duration, onEnd: onEnd,);

  Widget desktopTextSelectionToolbarButton({Key? key, required VoidCallback onPressed,}) =>
    DesktopTextSelectionToolbarButton(child: this, key: key, onPressed: onPressed,);

  Widget singleChildScrollView({Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, EdgeInsetsGeometry? padding, bool? primary, ScrollPhysics? physics, ScrollController? controller, DragStartBehavior dragStartBehavior = DragStartBehavior.start, Clip clipBehavior = Clip.hardEdge, HitTestBehavior hitTestBehavior = HitTestBehavior.opaque, String? restorationId, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual,}) =>
    SingleChildScrollView(child: this, key: key, scrollDirection: scrollDirection, reverse: reverse, padding: padding, primary: primary, physics: physics, controller: controller, dragStartBehavior: dragStartBehavior, clipBehavior: clipBehavior, hitTestBehavior: hitTestBehavior, restorationId: restorationId, keyboardDismissBehavior: keyboardDismissBehavior,);

  Widget animatedContainer({Key? key, AlignmentGeometry? alignment, EdgeInsetsGeometry? padding, Color? color, Decoration? decoration, Decoration? foregroundDecoration, double? width, double? height, BoxConstraints? constraints, EdgeInsetsGeometry? margin, Matrix4? transform, AlignmentGeometry? transformAlignment, Clip clipBehavior = Clip.none, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd,}) =>
    AnimatedContainer(child: this, key: key, alignment: alignment, padding: padding, color: color, decoration: decoration, foregroundDecoration: foregroundDecoration, width: width, height: height, constraints: constraints, margin: margin, transform: transform, transformAlignment: transformAlignment, clipBehavior: clipBehavior, curve: curve, duration: duration, onEnd: onEnd,);

  Widget animatedPadding({Key? key, required EdgeInsetsGeometry padding, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd,}) =>
    AnimatedPadding(child: this, key: key, padding: padding, curve: curve, duration: duration, onEnd: onEnd,);

  Widget animatedAlign({Key? key, required AlignmentGeometry alignment, double? heightFactor, double? widthFactor, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd,}) =>
    AnimatedAlign(child: this, key: key, alignment: alignment, heightFactor: heightFactor, widthFactor: widthFactor, curve: curve, duration: duration, onEnd: onEnd,);

  Widget animatedPositioned({Key? key, double? left, double? top, double? right, double? bottom, double? width, double? height, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd,}) =>
    AnimatedPositioned(child: this, key: key, left: left, top: top, right: right, bottom: bottom, width: width, height: height, curve: curve, duration: duration, onEnd: onEnd,);

  Widget animatedPositionedfromRect({Key? key, required Rect rect, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd,}) =>
    AnimatedPositioned.fromRect(child: this, key: key, rect: rect, curve: curve, duration: duration, onEnd: onEnd,);

  Widget animatedPositionedDirectional({Key? key, double? start, double? top, double? end, double? bottom, double? width, double? height, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd,}) =>
    AnimatedPositionedDirectional(child: this, key: key, start: start, top: top, end: end, bottom: bottom, width: width, height: height, curve: curve, duration: duration, onEnd: onEnd,);

  Widget animatedScale({Key? key, required double scale, Alignment alignment = Alignment.center, FilterQuality? filterQuality, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd,}) =>
    AnimatedScale(child: this, key: key, scale: scale, alignment: alignment, filterQuality: filterQuality, curve: curve, duration: duration, onEnd: onEnd,);

  Widget animatedRotation({Key? key, required double turns, Alignment alignment = Alignment.center, FilterQuality? filterQuality, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd,}) =>
    AnimatedRotation(child: this, key: key, turns: turns, alignment: alignment, filterQuality: filterQuality, curve: curve, duration: duration, onEnd: onEnd,);

  Widget animatedSlide({Key? key, required Offset offset, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd,}) =>
    AnimatedSlide(child: this, key: key, offset: offset, curve: curve, duration: duration, onEnd: onEnd,);

  Widget animatedOpacity({Key? key, required double opacity, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd, bool alwaysIncludeSemantics = false,}) =>
    AnimatedOpacity(child: this, key: key, opacity: opacity, curve: curve, duration: duration, onEnd: onEnd, alwaysIncludeSemantics: alwaysIncludeSemantics,);

  Widget animatedDefaultTextStyle({Key? key, required TextStyle style, TextAlign? textAlign, bool softWrap = true, TextOverflow overflow = TextOverflow.clip, int? maxLines, TextWidthBasis textWidthBasis = TextWidthBasis.parent, ui.TextHeightBehavior? textHeightBehavior, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd,}) =>
    AnimatedDefaultTextStyle(child: this, key: key, style: style, textAlign: textAlign, softWrap: softWrap, overflow: overflow, maxLines: maxLines, textWidthBasis: textWidthBasis, textHeightBehavior: textHeightBehavior, curve: curve, duration: duration, onEnd: onEnd,);

  Widget animatedPhysicalModel({Key? key, BoxShape shape = BoxShape.rectangle, Clip clipBehavior = Clip.none, BorderRadius? borderRadius, double elevation = 0.0, required Color color, bool animateColor = true, required Color shadowColor, bool animateShadowColor = true, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd,}) =>
    AnimatedPhysicalModel(child: this, key: key, shape: shape, clipBehavior: clipBehavior, borderRadius: borderRadius, elevation: elevation, color: color, animateColor: animateColor, shadowColor: shadowColor, animateShadowColor: animateShadowColor, curve: curve, duration: duration, onEnd: onEnd,);

  Widget animatedFractionallySizedBox({Key? key, AlignmentGeometry alignment = Alignment.center, double? heightFactor, double? widthFactor, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd,}) =>
    AnimatedFractionallySizedBox(child: this, key: key, alignment: alignment, heightFactor: heightFactor, widthFactor: widthFactor, curve: curve, duration: duration, onEnd: onEnd,);

  Widget gridPaper({Key? key, Color color = const Color(0x7FC3E8F3), double interval = 100.0, int divisions = 2, int subdivisions = 5,}) =>
    GridPaper(child: this, key: key, color: color, interval: interval, divisions: divisions, subdivisions: subdivisions,);

  Widget tweenAnimationBuilder<T extends Object?>({Key? key, required Tween<T> tween, required Duration duration, Curve curve = Curves.linear, required ValueWidgetBuilder<T> builder, VoidCallback? onEnd,}) =>
    TweenAnimationBuilder(child: this, key: key, tween: tween, duration: duration, curve: curve, builder: builder, onEnd: onEnd,);

  Widget defaultTextEditingShortcuts({Key? key,}) =>
    DefaultTextEditingShortcuts(child: this, key: key,);

  Widget slideTransition({Key? key, required Animation<Offset> position, bool transformHitTests = true, TextDirection? textDirection,}) =>
    SlideTransition(child: this, key: key, position: position, transformHitTests: transformHitTests, textDirection: textDirection,);

  Widget matrixTransition({Key? key, required Animation<double> animation, required TransformCallback onTransform, Alignment alignment = Alignment.center, FilterQuality? filterQuality,}) =>
    MatrixTransition(child: this, key: key, animation: animation, onTransform: onTransform, alignment: alignment, filterQuality: filterQuality,);

  Widget scaleTransition({Key? key, required Animation<double> scale, Alignment alignment = Alignment.center, FilterQuality? filterQuality,}) =>
    ScaleTransition(child: this, key: key, scale: scale, alignment: alignment, filterQuality: filterQuality,);

  Widget rotationTransition({Key? key, required Animation<double> turns, Alignment alignment = Alignment.center, FilterQuality? filterQuality,}) =>
    RotationTransition(child: this, key: key, turns: turns, alignment: alignment, filterQuality: filterQuality,);

  Widget sizeTransition({Key? key, Axis axis = Axis.vertical, required Animation<double> sizeFactor, double axisAlignment = 0.0, double? fixedCrossAxisSizeFactor,}) =>
    SizeTransition(child: this, key: key, axis: axis, sizeFactor: sizeFactor, axisAlignment: axisAlignment, fixedCrossAxisSizeFactor: fixedCrossAxisSizeFactor,);

  Widget fadeTransition({Key? key, required Animation<double> opacity, bool alwaysIncludeSemantics = false,}) =>
    FadeTransition(child: this, key: key, opacity: opacity, alwaysIncludeSemantics: alwaysIncludeSemantics,);

  Widget positionedTransition({Key? key, required Animation<RelativeRect> rect,}) =>
    PositionedTransition(child: this, key: key, rect: rect,);

  Widget relativePositionedTransition({Key? key, required Animation<Rect?> rect, required Size size,}) =>
    RelativePositionedTransition(child: this, key: key, rect: rect, size: size,);

  Widget decoratedBoxTransition({Key? key, required Animation<Decoration> decoration, DecorationPosition position = DecorationPosition.background,}) =>
    DecoratedBoxTransition(child: this, key: key, decoration: decoration, position: position,);

  Widget alignTransition({Key? key, required Animation<AlignmentGeometry> alignment, double? widthFactor, double? heightFactor,}) =>
    AlignTransition(child: this, key: key, alignment: alignment, widthFactor: widthFactor, heightFactor: heightFactor,);

  Widget defaultTextStyleTransition({Key? key, required Animation<TextStyle> style, TextAlign? textAlign, bool softWrap = true, TextOverflow overflow = TextOverflow.clip, int? maxLines,}) =>
    DefaultTextStyleTransition(child: this, key: key, style: style, textAlign: textAlign, softWrap: softWrap, overflow: overflow, maxLines: maxLines,);

  Widget listenableBuilder({Key? key, required Listenable listenable, required TransitionBuilder builder,}) =>
    ListenableBuilder(child: this, key: key, listenable: listenable, builder: builder,);

  Widget animatedBuilder({Key? key, required Listenable animation, required Widget Function(BuildContext, Widget?) builder,}) =>
    AnimatedBuilder(child: this, key: key, animation: animation, builder: builder,);

  Widget pageStorage({Key? key, required PageStorageBucket bucket,}) =>
    PageStorage(child: this, key: key, bucket: bucket,);

  Widget tapRegionSurface({Key? key,}) =>
    TapRegionSurface(child: this, key: key,);

  Widget tapRegion({Key? key, bool enabled = true, HitTestBehavior behavior = HitTestBehavior.deferToChild, TapRegionCallback? onTapOutside, TapRegionCallback? onTapInside, Object? groupId, bool consumeOutsideTaps = false, String? debugLabel,}) =>
    TapRegion(child: this, key: key, enabled: enabled, behavior: behavior, onTapOutside: onTapOutside, onTapInside: onTapInside, groupId: groupId, consumeOutsideTaps: consumeOutsideTaps, debugLabel: debugLabel,);

  Widget textFieldTapRegion({Key? key, bool enabled = true, TapRegionCallback? onTapOutside, TapRegionCallback? onTapInside, bool consumeOutsideTaps = false, String? debugLabel, Object? groupId = EditableText,}) =>
    TextFieldTapRegion(child: this, key: key, enabled: enabled, onTapOutside: onTapOutside, onTapInside: onTapInside, consumeOutsideTaps: consumeOutsideTaps, debugLabel: debugLabel, groupId: groupId,);

  Widget backButtonListener({Key? key, required ValueGetter<Future<bool>> onBackButtonPressed,}) =>
    BackButtonListener(child: this, key: key, onBackButtonPressed: onBackButtonPressed,);

  Widget directionality({Key? key, required TextDirection textDirection,}) =>
    Directionality(child: this, key: key, textDirection: textDirection,);

  Widget opacity({Key? key, required double opacity, bool alwaysIncludeSemantics = false,}) =>
    Opacity(child: this, key: key, opacity: opacity, alwaysIncludeSemantics: alwaysIncludeSemantics,);

  Widget shaderMask({Key? key, required ShaderCallback shaderCallback, BlendMode blendMode = BlendMode.modulate,}) =>
    ShaderMask(child: this, key: key, shaderCallback: shaderCallback, blendMode: blendMode,);

  Widget backdropFilter({Key? key, required ui.ImageFilter filter, BlendMode blendMode = BlendMode.srcOver, bool enabled = true,}) =>
    BackdropFilter(child: this, key: key, filter: filter, blendMode: blendMode, enabled: enabled,);

  Widget customPaint({Key? key, CustomPainter? painter, CustomPainter? foregroundPainter, Size size = Size.zero, bool isComplex = false, bool willChange = false,}) =>
    CustomPaint(child: this, key: key, painter: painter, foregroundPainter: foregroundPainter, size: size, isComplex: isComplex, willChange: willChange,);

  Widget clipRect({Key? key, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.hardEdge,}) =>
    ClipRect(child: this, key: key, clipper: clipper, clipBehavior: clipBehavior,);

  Widget clipRRect({Key? key, BorderRadiusGeometry borderRadius = BorderRadius.zero, CustomClipper<RRect>? clipper, Clip clipBehavior = Clip.antiAlias,}) =>
    ClipRRect(child: this, key: key, borderRadius: borderRadius, clipper: clipper, clipBehavior: clipBehavior,);

  Widget clipOval({Key? key, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.antiAlias,}) =>
    ClipOval(child: this, key: key, clipper: clipper, clipBehavior: clipBehavior,);

  Widget clipPath({Key? key, CustomClipper<Path>? clipper, Clip clipBehavior = Clip.antiAlias,}) =>
    ClipPath(child: this, key: key, clipper: clipper, clipBehavior: clipBehavior,);

  Widget physicalModel({Key? key, BoxShape shape = BoxShape.rectangle, Clip clipBehavior = Clip.none, BorderRadius? borderRadius, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000),}) =>
    PhysicalModel(child: this, key: key, shape: shape, clipBehavior: clipBehavior, borderRadius: borderRadius, elevation: elevation, color: color, shadowColor: shadowColor,);

  Widget physicalShape({Key? key, required CustomClipper<Path> clipper, Clip clipBehavior = Clip.none, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000),}) =>
    PhysicalShape(child: this, key: key, clipper: clipper, clipBehavior: clipBehavior, elevation: elevation, color: color, shadowColor: shadowColor,);

  Widget transform({Key? key, required Matrix4 transform, Offset? origin, AlignmentGeometry? alignment, bool transformHitTests = true, FilterQuality? filterQuality,}) =>
    Transform(child: this, key: key, transform: transform, origin: origin, alignment: alignment, transformHitTests: transformHitTests, filterQuality: filterQuality,);

  Widget transformrotate({Key? key, required double angle, Offset? origin, AlignmentGeometry? alignment = Alignment.center, bool transformHitTests = true, FilterQuality? filterQuality,}) =>
    Transform.rotate(child: this, key: key, angle: angle, origin: origin, alignment: alignment, transformHitTests: transformHitTests, filterQuality: filterQuality,);

  Widget transformtranslate({Key? key, required Offset offset, bool transformHitTests = true, FilterQuality? filterQuality,}) =>
    Transform.translate(child: this, key: key, offset: offset, transformHitTests: transformHitTests, filterQuality: filterQuality,);

  Widget transformscale({Key? key, double? scale, double? scaleX, double? scaleY, Offset? origin, AlignmentGeometry? alignment = Alignment.center, bool transformHitTests = true, FilterQuality? filterQuality,}) =>
    Transform.scale(child: this, key: key, scale: scale, scaleX: scaleX, scaleY: scaleY, origin: origin, alignment: alignment, transformHitTests: transformHitTests, filterQuality: filterQuality,);

  Widget transformflip({Key? key, bool flipX = false, bool flipY = false, Offset? origin, bool transformHitTests = true, FilterQuality? filterQuality,}) =>
    Transform.flip(child: this, key: key, flipX: flipX, flipY: flipY, origin: origin, transformHitTests: transformHitTests, filterQuality: filterQuality,);

  Widget compositedTransformTarget({Key? key, required LayerLink link,}) =>
    CompositedTransformTarget(child: this, key: key, link: link,);

  Widget compositedTransformFollower({Key? key, required LayerLink link, bool showWhenUnlinked = true, Offset offset = Offset.zero, Alignment targetAnchor = Alignment.topLeft, Alignment followerAnchor = Alignment.topLeft,}) =>
    CompositedTransformFollower(child: this, key: key, link: link, showWhenUnlinked: showWhenUnlinked, offset: offset, targetAnchor: targetAnchor, followerAnchor: followerAnchor,);

  Widget fittedBox({Key? key, BoxFit fit = BoxFit.contain, AlignmentGeometry alignment = Alignment.center, Clip clipBehavior = Clip.none,}) =>
    FittedBox(child: this, key: key, fit: fit, alignment: alignment, clipBehavior: clipBehavior,);

  Widget fractionalTranslation({Key? key, required Offset translation, bool transformHitTests = true,}) =>
    FractionalTranslation(child: this, key: key, translation: translation, transformHitTests: transformHitTests,);

  Widget rotatedBox({Key? key, required int quarterTurns,}) =>
    RotatedBox(child: this, key: key, quarterTurns: quarterTurns,);

  Widget padding({Key? key, required EdgeInsetsGeometry padding,}) =>
    Padding(child: this, key: key, padding: padding,);

  Widget align({Key? key, AlignmentGeometry alignment = Alignment.center, double? widthFactor, double? heightFactor,}) =>
    Align(child: this, key: key, alignment: alignment, widthFactor: widthFactor, heightFactor: heightFactor,);

  Widget center({Key? key, double? widthFactor, double? heightFactor,}) =>
    Center(child: this, key: key, widthFactor: widthFactor, heightFactor: heightFactor,);

  Widget customSingleChildLayout({Key? key, required SingleChildLayoutDelegate delegate,}) =>
    CustomSingleChildLayout(child: this, key: key, delegate: delegate,);

  Widget layoutId({Key? key, required Object id,}) =>
    LayoutId(child: this, key: key, id: id,);

  Widget sizedBox({Key? key, double? width, double? height,}) =>
    SizedBox(child: this, key: key, width: width, height: height,);

  Widget sizedBoxexpand({Key? key,}) =>
    SizedBox.expand(child: this, key: key,);

  Widget sizedBoxshrink({Key? key,}) =>
    SizedBox.shrink(child: this, key: key,);

  Widget sizedBoxfromSize({Key? key, Size? size,}) =>
    SizedBox.fromSize(child: this, key: key, size: size,);

  Widget sizedBoxsquare({Key? key, double? dimension,}) =>
    SizedBox.square(child: this, key: key, dimension: dimension,);

  Widget constrainedBox({Key? key, required BoxConstraints constraints,}) =>
    ConstrainedBox(child: this, key: key, constraints: constraints,);

  Widget constraintsTransformBox({Key? key, TextDirection? textDirection, AlignmentGeometry alignment = Alignment.center, required BoxConstraintsTransform constraintsTransform, Clip clipBehavior = Clip.none, String debugTransformType = '',}) =>
    ConstraintsTransformBox(child: this, key: key, textDirection: textDirection, alignment: alignment, constraintsTransform: constraintsTransform, clipBehavior: clipBehavior, debugTransformType: debugTransformType,);

  Widget unconstrainedBox({Key? key, TextDirection? textDirection, AlignmentGeometry alignment = Alignment.center, Axis? constrainedAxis, Clip clipBehavior = Clip.none,}) =>
    UnconstrainedBox(child: this, key: key, textDirection: textDirection, alignment: alignment, constrainedAxis: constrainedAxis, clipBehavior: clipBehavior,);

  Widget fractionallySizedBox({Key? key, AlignmentGeometry alignment = Alignment.center, double? widthFactor, double? heightFactor,}) =>
    FractionallySizedBox(child: this, key: key, alignment: alignment, widthFactor: widthFactor, heightFactor: heightFactor,);

  Widget limitedBox({Key? key, double maxWidth = double.infinity, double maxHeight = double.infinity,}) =>
    LimitedBox(child: this, key: key, maxWidth: maxWidth, maxHeight: maxHeight,);

  Widget overflowBox({Key? key, AlignmentGeometry alignment = Alignment.center, double? minWidth, double? maxWidth, double? minHeight, double? maxHeight, OverflowBoxFit fit = OverflowBoxFit.max,}) =>
    OverflowBox(child: this, key: key, alignment: alignment, minWidth: minWidth, maxWidth: maxWidth, minHeight: minHeight, maxHeight: maxHeight, fit: fit,);

  Widget sizedOverflowBox({Key? key, required Size size, AlignmentGeometry alignment = Alignment.center,}) =>
    SizedOverflowBox(child: this, key: key, size: size, alignment: alignment,);

  Widget offstage({Key? key, bool offstage = true,}) =>
    Offstage(child: this, key: key, offstage: offstage,);

  Widget aspectRatio({Key? key, required double aspectRatio,}) =>
    AspectRatio(child: this, key: key, aspectRatio: aspectRatio,);

  Widget intrinsicWidth({Key? key, double? stepWidth, double? stepHeight,}) =>
    IntrinsicWidth(child: this, key: key, stepWidth: stepWidth, stepHeight: stepHeight,);

  Widget intrinsicHeight({Key? key,}) =>
    IntrinsicHeight(child: this, key: key,);

  Widget baseline({Key? key, required double baseline, required TextBaseline baselineType,}) =>
    Baseline(child: this, key: key, baseline: baseline, baselineType: baselineType,);

  Widget ignoreBaseline({Key? key,}) =>
    IgnoreBaseline(child: this, key: key,);

  Widget sliverToBoxAdapter({Key? key,}) =>
    SliverToBoxAdapter(child: this, key: key,);

  Widget positioned({Key? key, double? left, double? top, double? right, double? bottom, double? width, double? height,}) =>
    Positioned(child: this, key: key, left: left, top: top, right: right, bottom: bottom, width: width, height: height,);

  Widget positionedfromRect({Key? key, required Rect rect,}) =>
    Positioned.fromRect(child: this, key: key, rect: rect,);

  Widget positionedfromRelativeRect({Key? key, required RelativeRect rect,}) =>
    Positioned.fromRelativeRect(child: this, key: key, rect: rect,);

  Widget positionedfill({Key? key, double? left = 0.0, double? top = 0.0, double? right = 0.0, double? bottom = 0.0,}) =>
    Positioned.fill(child: this, key: key, left: left, top: top, right: right, bottom: bottom,);

  Widget positioneddirectional({Key? key, required TextDirection textDirection, double? start, double? top, double? end, double? bottom, double? width, double? height,}) =>
    Positioned.directional(child: this, key: key, textDirection: textDirection, start: start, top: top, end: end, bottom: bottom, width: width, height: height,);

  Widget positionedDirectional({Key? key, double? start, double? top, double? end, double? bottom, double? width, double? height,}) =>
    PositionedDirectional(child: this, key: key, start: start, top: top, end: end, bottom: bottom, width: width, height: height,);

  Widget flexible({Key? key, int flex = 1, FlexFit fit = FlexFit.loose,}) =>
    Flexible(child: this, key: key, flex: flex, fit: fit,);

  Widget expanded({Key? key, int flex = 1,}) =>
    Expanded(child: this, key: key, flex: flex,);

  Widget defaultAssetBundle({Key? key, required AssetBundle bundle,}) =>
    DefaultAssetBundle(child: this, key: key, bundle: bundle,);

  Widget listener({Key? key, PointerDownEventListener? onPointerDown, PointerMoveEventListener? onPointerMove, PointerUpEventListener? onPointerUp, PointerHoverEventListener? onPointerHover, PointerCancelEventListener? onPointerCancel, PointerPanZoomStartEventListener? onPointerPanZoomStart, PointerPanZoomUpdateEventListener? onPointerPanZoomUpdate, PointerPanZoomEndEventListener? onPointerPanZoomEnd, PointerSignalEventListener? onPointerSignal, HitTestBehavior behavior = HitTestBehavior.deferToChild,}) =>
    Listener(child: this, key: key, onPointerDown: onPointerDown, onPointerMove: onPointerMove, onPointerUp: onPointerUp, onPointerHover: onPointerHover, onPointerCancel: onPointerCancel, onPointerPanZoomStart: onPointerPanZoomStart, onPointerPanZoomUpdate: onPointerPanZoomUpdate, onPointerPanZoomEnd: onPointerPanZoomEnd, onPointerSignal: onPointerSignal, behavior: behavior,);

  Widget mouseRegion({Key? key, PointerEnterEventListener? onEnter, PointerExitEventListener? onExit, PointerHoverEventListener? onHover, MouseCursor cursor = MouseCursor.defer, bool opaque = true, HitTestBehavior? hitTestBehavior,}) =>
    MouseRegion(child: this, key: key, onEnter: onEnter, onExit: onExit, onHover: onHover, cursor: cursor, opaque: opaque, hitTestBehavior: hitTestBehavior,);

  Widget repaintBoundary({Key? key,}) =>
    RepaintBoundary(child: this, key: key,);

  Widget repaintBoundarywrap(int childIndex) =>
    RepaintBoundary.wrap(this, childIndex,);

  Widget ignorePointer({Key? key, bool ignoring = true, bool? ignoringSemantics,}) =>
    IgnorePointer(child: this, key: key, ignoring: ignoring, ignoringSemantics: ignoringSemantics,);

  Widget absorbPointer({Key? key, bool absorbing = true, bool? ignoringSemantics,}) =>
    AbsorbPointer(child: this, key: key, absorbing: absorbing, ignoringSemantics: ignoringSemantics,);

  Widget metaData({Key? key, HitTestBehavior behavior = HitTestBehavior.deferToChild,}) =>
    MetaData(child: this, key: key, behavior: behavior,);

  Widget semantics({Key? key, bool container = false, bool explicitChildNodes = false, bool excludeSemantics = false, bool blockUserActions = false, bool? enabled, bool? checked, bool? mixed, bool? selected, bool? toggled, bool? button, bool? slider, bool? keyboardKey, bool? link, Uri? linkUrl, bool? header, int? headingLevel, bool? textField, bool? readOnly, bool? focusable, bool? focused, bool? inMutuallyExclusiveGroup, bool? obscured, bool? multiline, bool? scopesRoute, bool? namesRoute, bool? hidden, bool? image, bool? liveRegion, bool? expanded, int? maxValueLength, int? currentValueLength, String? identifier, String? label, AttributedString? attributedLabel, String? value, AttributedString? attributedValue, String? increasedValue, AttributedString? attributedIncreasedValue, String? decreasedValue, AttributedString? attributedDecreasedValue, String? hint, AttributedString? attributedHint, String? tooltip, String? onTapHint, String? onLongPressHint, TextDirection? textDirection, SemanticsSortKey? sortKey, SemanticsTag? tagForChildren, VoidCallback? onTap, VoidCallback? onLongPress, VoidCallback? onScrollLeft, VoidCallback? onScrollRight, VoidCallback? onScrollUp, VoidCallback? onScrollDown, VoidCallback? onIncrease, VoidCallback? onDecrease, VoidCallback? onCopy, VoidCallback? onCut, VoidCallback? onPaste, VoidCallback? onDismiss, MoveCursorHandler? onMoveCursorForwardByCharacter, MoveCursorHandler? onMoveCursorBackwardByCharacter, SetSelectionHandler? onSetSelection, SetTextHandler? onSetText, VoidCallback? onDidGainAccessibilityFocus, VoidCallback? onDidLoseAccessibilityFocus, VoidCallback? onFocus, Map<CustomSemanticsAction, VoidCallback>? customSemanticsActions,}) =>
    Semantics(child: this, key: key, container: container, explicitChildNodes: explicitChildNodes, excludeSemantics: excludeSemantics, blockUserActions: blockUserActions, enabled: enabled, checked: checked, mixed: mixed, selected: selected, toggled: toggled, button: button, slider: slider, keyboardKey: keyboardKey, link: link, linkUrl: linkUrl, header: header, headingLevel: headingLevel, textField: textField, readOnly: readOnly, focusable: focusable, focused: focused, inMutuallyExclusiveGroup: inMutuallyExclusiveGroup, obscured: obscured, multiline: multiline, scopesRoute: scopesRoute, namesRoute: namesRoute, hidden: hidden, image: image, liveRegion: liveRegion, expanded: expanded, maxValueLength: maxValueLength, currentValueLength: currentValueLength, identifier: identifier, label: label, attributedLabel: attributedLabel, value: value, attributedValue: attributedValue, increasedValue: increasedValue, attributedIncreasedValue: attributedIncreasedValue, decreasedValue: decreasedValue, attributedDecreasedValue: attributedDecreasedValue, hint: hint, attributedHint: attributedHint, tooltip: tooltip, onTapHint: onTapHint, onLongPressHint: onLongPressHint, textDirection: textDirection, sortKey: sortKey, tagForChildren: tagForChildren, onTap: onTap, onLongPress: onLongPress, onScrollLeft: onScrollLeft, onScrollRight: onScrollRight, onScrollUp: onScrollUp, onScrollDown: onScrollDown, onIncrease: onIncrease, onDecrease: onDecrease, onCopy: onCopy, onCut: onCut, onPaste: onPaste, onDismiss: onDismiss, onMoveCursorForwardByCharacter: onMoveCursorForwardByCharacter, onMoveCursorBackwardByCharacter: onMoveCursorBackwardByCharacter, onSetSelection: onSetSelection, onSetText: onSetText, onDidGainAccessibilityFocus: onDidGainAccessibilityFocus, onDidLoseAccessibilityFocus: onDidLoseAccessibilityFocus, onFocus: onFocus, customSemanticsActions: customSemanticsActions,);

  Widget semanticsfromProperties({Key? key, bool container = false, bool explicitChildNodes = false, bool excludeSemantics = false, bool blockUserActions = false, required SemanticsProperties properties,}) =>
    Semantics.fromProperties(child: this, key: key, container: container, explicitChildNodes: explicitChildNodes, excludeSemantics: excludeSemantics, blockUserActions: blockUserActions, properties: properties,);

  Widget mergeSemantics({Key? key,}) =>
    MergeSemantics(child: this, key: key,);

  Widget blockSemantics({Key? key, bool blocking = true,}) =>
    BlockSemantics(child: this, key: key, blocking: blocking,);

  Widget excludeSemantics({Key? key, bool excluding = true,}) =>
    ExcludeSemantics(child: this, key: key, excluding: excluding,);

  Widget indexedSemantics({Key? key, required int index,}) =>
    IndexedSemantics(child: this, key: key, index: index,);

  Widget keyedSubtree({Key? key,}) =>
    KeyedSubtree(child: this, key: key,);

  Widget keyedSubtreewrap(int childIndex) =>
    KeyedSubtree.wrap(this, childIndex,);

  Widget coloredBox({required Color color, Key? key,}) =>
    ColoredBox(child: this, color: color, key: key,);

  Widget gestureDetector({Key? key, GestureTapDownCallback? onTapDown, GestureTapUpCallback? onTapUp, GestureTapCallback? onTap, GestureTapCancelCallback? onTapCancel, GestureTapCallback? onSecondaryTap, GestureTapDownCallback? onSecondaryTapDown, GestureTapUpCallback? onSecondaryTapUp, GestureTapCancelCallback? onSecondaryTapCancel, GestureTapDownCallback? onTertiaryTapDown, GestureTapUpCallback? onTertiaryTapUp, GestureTapCancelCallback? onTertiaryTapCancel, GestureTapDownCallback? onDoubleTapDown, GestureTapCallback? onDoubleTap, GestureTapCancelCallback? onDoubleTapCancel, GestureLongPressDownCallback? onLongPressDown, GestureLongPressCancelCallback? onLongPressCancel, GestureLongPressCallback? onLongPress, GestureLongPressStartCallback? onLongPressStart, GestureLongPressMoveUpdateCallback? onLongPressMoveUpdate, GestureLongPressUpCallback? onLongPressUp, GestureLongPressEndCallback? onLongPressEnd, GestureLongPressDownCallback? onSecondaryLongPressDown, GestureLongPressCancelCallback? onSecondaryLongPressCancel, GestureLongPressCallback? onSecondaryLongPress, GestureLongPressStartCallback? onSecondaryLongPressStart, GestureLongPressMoveUpdateCallback? onSecondaryLongPressMoveUpdate, GestureLongPressUpCallback? onSecondaryLongPressUp, GestureLongPressEndCallback? onSecondaryLongPressEnd, GestureLongPressDownCallback? onTertiaryLongPressDown, GestureLongPressCancelCallback? onTertiaryLongPressCancel, GestureLongPressCallback? onTertiaryLongPress, GestureLongPressStartCallback? onTertiaryLongPressStart, GestureLongPressMoveUpdateCallback? onTertiaryLongPressMoveUpdate, GestureLongPressUpCallback? onTertiaryLongPressUp, GestureLongPressEndCallback? onTertiaryLongPressEnd, GestureDragDownCallback? onVerticalDragDown, GestureDragStartCallback? onVerticalDragStart, GestureDragUpdateCallback? onVerticalDragUpdate, GestureDragEndCallback? onVerticalDragEnd, GestureDragCancelCallback? onVerticalDragCancel, GestureDragDownCallback? onHorizontalDragDown, GestureDragStartCallback? onHorizontalDragStart, GestureDragUpdateCallback? onHorizontalDragUpdate, GestureDragEndCallback? onHorizontalDragEnd, GestureDragCancelCallback? onHorizontalDragCancel, GestureForcePressStartCallback? onForcePressStart, GestureForcePressPeakCallback? onForcePressPeak, GestureForcePressUpdateCallback? onForcePressUpdate, GestureForcePressEndCallback? onForcePressEnd, GestureDragDownCallback? onPanDown, GestureDragStartCallback? onPanStart, GestureDragUpdateCallback? onPanUpdate, GestureDragEndCallback? onPanEnd, GestureDragCancelCallback? onPanCancel, GestureScaleStartCallback? onScaleStart, GestureScaleUpdateCallback? onScaleUpdate, GestureScaleEndCallback? onScaleEnd, HitTestBehavior? behavior, bool excludeFromSemantics = false, DragStartBehavior dragStartBehavior = DragStartBehavior.start, bool trackpadScrollCausesScale = false, Offset trackpadScrollToScaleFactor = kDefaultTrackpadScrollToScaleFactor, Set<PointerDeviceKind>? supportedDevices,}) =>
    GestureDetector(child: this, key: key, onTapDown: onTapDown, onTapUp: onTapUp, onTap: onTap, onTapCancel: onTapCancel, onSecondaryTap: onSecondaryTap, onSecondaryTapDown: onSecondaryTapDown, onSecondaryTapUp: onSecondaryTapUp, onSecondaryTapCancel: onSecondaryTapCancel, onTertiaryTapDown: onTertiaryTapDown, onTertiaryTapUp: onTertiaryTapUp, onTertiaryTapCancel: onTertiaryTapCancel, onDoubleTapDown: onDoubleTapDown, onDoubleTap: onDoubleTap, onDoubleTapCancel: onDoubleTapCancel, onLongPressDown: onLongPressDown, onLongPressCancel: onLongPressCancel, onLongPress: onLongPress, onLongPressStart: onLongPressStart, onLongPressMoveUpdate: onLongPressMoveUpdate, onLongPressUp: onLongPressUp, onLongPressEnd: onLongPressEnd, onSecondaryLongPressDown: onSecondaryLongPressDown, onSecondaryLongPressCancel: onSecondaryLongPressCancel, onSecondaryLongPress: onSecondaryLongPress, onSecondaryLongPressStart: onSecondaryLongPressStart, onSecondaryLongPressMoveUpdate: onSecondaryLongPressMoveUpdate, onSecondaryLongPressUp: onSecondaryLongPressUp, onSecondaryLongPressEnd: onSecondaryLongPressEnd, onTertiaryLongPressDown: onTertiaryLongPressDown, onTertiaryLongPressCancel: onTertiaryLongPressCancel, onTertiaryLongPress: onTertiaryLongPress, onTertiaryLongPressStart: onTertiaryLongPressStart, onTertiaryLongPressMoveUpdate: onTertiaryLongPressMoveUpdate, onTertiaryLongPressUp: onTertiaryLongPressUp, onTertiaryLongPressEnd: onTertiaryLongPressEnd, onVerticalDragDown: onVerticalDragDown, onVerticalDragStart: onVerticalDragStart, onVerticalDragUpdate: onVerticalDragUpdate, onVerticalDragEnd: onVerticalDragEnd, onVerticalDragCancel: onVerticalDragCancel, onHorizontalDragDown: onHorizontalDragDown, onHorizontalDragStart: onHorizontalDragStart, onHorizontalDragUpdate: onHorizontalDragUpdate, onHorizontalDragEnd: onHorizontalDragEnd, onHorizontalDragCancel: onHorizontalDragCancel, onForcePressStart: onForcePressStart, onForcePressPeak: onForcePressPeak, onForcePressUpdate: onForcePressUpdate, onForcePressEnd: onForcePressEnd, onPanDown: onPanDown, onPanStart: onPanStart, onPanUpdate: onPanUpdate, onPanEnd: onPanEnd, onPanCancel: onPanCancel, onScaleStart: onScaleStart, onScaleUpdate: onScaleUpdate, onScaleEnd: onScaleEnd, behavior: behavior, excludeFromSemantics: excludeFromSemantics, dragStartBehavior: dragStartBehavior, trackpadScrollCausesScale: trackpadScrollCausesScale, trackpadScrollToScaleFactor: trackpadScrollToScaleFactor, supportedDevices: supportedDevices,);

  Widget rawGestureDetector({Key? key, Map<Type, GestureRecognizerFactory> gestures = const <Type, GestureRecognizerFactory>{}, HitTestBehavior? behavior, bool excludeFromSemantics = false, SemanticsGestureDelegate? semantics,}) =>
    RawGestureDetector(child: this, key: key, gestures: gestures, behavior: behavior, excludeFromSemantics: excludeFromSemantics, semantics: semantics,);

  Widget defaultTextStyle({Key? key, required TextStyle style, TextAlign? textAlign, bool softWrap = true, TextOverflow overflow = TextOverflow.clip, int? maxLines, TextWidthBasis textWidthBasis = TextWidthBasis.parent, ui.TextHeightBehavior? textHeightBehavior,}) =>
    DefaultTextStyle(child: this, key: key, style: style, textAlign: textAlign, softWrap: softWrap, overflow: overflow, maxLines: maxLines, textWidthBasis: textWidthBasis, textHeightBehavior: textHeightBehavior,);

  Widget defaultTextHeightBehavior({Key? key, required TextHeightBehavior textHeightBehavior,}) =>
    DefaultTextHeightBehavior(child: this, key: key, textHeightBehavior: textHeightBehavior,);

  Widget actionListener({Key? key, required ActionListenerCallback listener, required Action<Intent> action,}) =>
    ActionListener(child: this, key: key, listener: listener, action: action,);

  Widget actions({Key? key, ActionDispatcher? dispatcher, required Map<Type, Action<Intent>> actions,}) =>
    Actions(child: this, key: key, dispatcher: dispatcher, actions: actions,);

  Widget focusableActionDetector({Key? key, bool enabled = true, FocusNode? focusNode, bool autofocus = false, bool descendantsAreFocusable = true, bool descendantsAreTraversable = true, Map<ShortcutActivator, Intent>? shortcuts, Map<Type, Action<Intent>>? actions, ValueChanged<bool>? onShowFocusHighlight, ValueChanged<bool>? onShowHoverHighlight, ValueChanged<bool>? onFocusChange, MouseCursor mouseCursor = MouseCursor.defer, bool includeFocusSemantics = true,}) =>
    FocusableActionDetector(child: this, key: key, enabled: enabled, focusNode: focusNode, autofocus: autofocus, descendantsAreFocusable: descendantsAreFocusable, descendantsAreTraversable: descendantsAreTraversable, shortcuts: shortcuts, actions: actions, onShowFocusHighlight: onShowFocusHighlight, onShowHoverHighlight: onShowHoverHighlight, onFocusChange: onFocusChange, mouseCursor: mouseCursor, includeFocusSemantics: includeFocusSemantics,);

  Widget form({Key? key, bool? canPop, PopInvokedCallback? onPopInvoked, PopInvokedWithResultCallback<Object?>? onPopInvokedWithResult, WillPopCallback? onWillPop, VoidCallback? onChanged, AutovalidateMode? autovalidateMode,}) =>
    Form(child: this, key: key, canPop: canPop, onPopInvoked: onPopInvoked, onPopInvokedWithResult: onPopInvokedWithResult, onWillPop: onWillPop, onChanged: onChanged, autovalidateMode: autovalidateMode,);

  Widget undoHistory<T>({Key? key, bool Function(T? oldValue, T newValue)? shouldChangeUndoStack, required ValueNotifier<T> value, required void Function(T value) onTriggered, required FocusNode focusNode, T Function(T value)? undoStackModifier, UndoHistoryController? controller,}) =>
    UndoHistory(child: this, key: key, shouldChangeUndoStack: shouldChangeUndoStack, value: value, onTriggered: onTriggered, focusNode: focusNode, undoStackModifier: undoStackModifier, controller: controller,);

  Widget selectionContainer({Key? key, SelectionRegistrar? registrar, required SelectionContainerDelegate delegate,}) =>
    SelectionContainer(child: this, key: key, registrar: registrar, delegate: delegate,);

  Widget selectionContainerdisabled({Key? key,}) =>
    SelectionContainer.disabled(child: this, key: key,);

  Widget selectionRegistrarScope({Key? key, required SelectionRegistrar registrar,}) =>
    SelectionRegistrarScope(child: this, key: key, registrar: registrar,);

  Widget reorderableDragStartListener({Key? key, required int index, bool enabled = true,}) =>
    ReorderableDragStartListener(child: this, key: key, index: index, enabled: enabled,);

  Widget reorderableDelayedDragStartListener({Key? key, required int index, bool enabled = true,}) =>
    ReorderableDelayedDragStartListener(child: this, key: key, index: index, enabled: enabled,);

  Widget heroControllerScope({Key? key, required HeroController controller,}) =>
    HeroControllerScope(child: this, key: key, controller: controller,);

  Widget heroControllerScopenone({Key? key,}) =>
    HeroControllerScope.none(child: this, key: key,);

  Widget popScope<T>({Key? key, bool canPop = true, PopInvokedWithResultCallback<T>? onPopInvokedWithResult, PopInvokedCallback? onPopInvoked,}) =>
    PopScope(child: this, key: key, canPop: canPop, onPopInvokedWithResult: onPopInvokedWithResult, onPopInvoked: onPopInvoked,);

  Widget preferredSize({Key? key, required Size preferredSize,}) =>
    PreferredSize(child: this, key: key, preferredSize: preferredSize,);

  Widget valueListenableBuilder<T>({Key? key, required ValueListenable<T> valueListenable, required ValueWidgetBuilder<T> builder,}) =>
    ValueListenableBuilder(child: this, key: key, valueListenable: valueListenable, builder: builder,);

  Widget navigatorPopHandler<T>({Key? key, VoidCallback? onPop, PopResultCallback<T>? onPopWithResult, bool enabled = true,}) =>
    NavigatorPopHandler(child: this, key: key, onPop: onPop, onPopWithResult: onPopWithResult, enabled: enabled,);

  Widget mediaQuery({Key? key, required MediaQueryData data,}) =>
    MediaQuery(child: this, key: key, data: data,);

  Widget mediaQueryremovePadding({Key? key, required BuildContext context, bool removeLeft = false, bool removeTop = false, bool removeRight = false, bool removeBottom = false,}) =>
    MediaQuery.removePadding(child: this, key: key, context: context, removeLeft: removeLeft, removeTop: removeTop, removeRight: removeRight, removeBottom: removeBottom,);

  Widget mediaQueryremoveViewInsets({Key? key, required BuildContext context, bool removeLeft = false, bool removeTop = false, bool removeRight = false, bool removeBottom = false,}) =>
    MediaQuery.removeViewInsets(child: this, key: key, context: context, removeLeft: removeLeft, removeTop: removeTop, removeRight: removeRight, removeBottom: removeBottom,);

  Widget mediaQueryremoveViewPadding({Key? key, required BuildContext context, bool removeLeft = false, bool removeTop = false, bool removeRight = false, bool removeBottom = false,}) =>
    MediaQuery.removeViewPadding(child: this, key: key, context: context, removeLeft: removeLeft, removeTop: removeTop, removeRight: removeRight, removeBottom: removeBottom,);

  Widget draggableScrollableActuator({Key? key,}) =>
    DraggableScrollableActuator(child: this, key: key,);

  Widget decoratedBox({Key? key, required Decoration decoration, DecorationPosition position = DecorationPosition.background,}) =>
    DecoratedBox(child: this, key: key, decoration: decoration, position: position,);

  Widget container({Key? key, AlignmentGeometry? alignment, EdgeInsetsGeometry? padding, Color? color, Decoration? decoration, Decoration? foregroundDecoration, double? width, double? height, BoxConstraints? constraints, EdgeInsetsGeometry? margin, Matrix4? transform, AlignmentGeometry? transformAlignment, Clip clipBehavior = Clip.none,}) =>
    Container(child: this, key: key, alignment: alignment, padding: padding, color: color, decoration: decoration, foregroundDecoration: foregroundDecoration, width: width, height: height, constraints: constraints, margin: margin, transform: transform, transformAlignment: transformAlignment, clipBehavior: clipBehavior,);

  Widget placeholder({Key? key, Color color = const Color(0xFF455A64), double strokeWidth = 2.0, double fallbackWidth = 400.0, double fallbackHeight = 400.0,}) =>
    Placeholder(child: this, key: key, color: color, strokeWidth: strokeWidth, fallbackWidth: fallbackWidth, fallbackHeight: fallbackHeight,);

  Widget primaryScrollController({Key? key, required ScrollController controller, Set<TargetPlatform> automaticallyInheritForPlatforms = _kMobilePlatforms, Axis? scrollDirection = Axis.vertical,}) =>
    PrimaryScrollController(child: this, key: key, controller: controller, automaticallyInheritForPlatforms: automaticallyInheritForPlatforms, scrollDirection: scrollDirection,);

  Widget primaryScrollControllernone({Key? key,}) =>
    PrimaryScrollController.none(child: this, key: key,);

  Widget focusTraversalOrder({Key? key, required FocusOrder order,}) =>
    FocusTraversalOrder(child: this, key: key, order: order,);

  Widget focusTraversalGroup({Key? key, FocusTraversalPolicy? policy, bool descendantsAreFocusable = true, bool descendantsAreTraversable = true,}) =>
    FocusTraversalGroup(child: this, key: key, policy: policy, descendantsAreFocusable: descendantsAreFocusable, descendantsAreTraversable: descendantsAreTraversable,);

  Widget excludeFocusTraversal({Key? key, bool excluding = true,}) =>
    ExcludeFocusTraversal(child: this, key: key, excluding: excluding,);

  Widget colorFiltered({required ColorFilter colorFilter, Key? key,}) =>
    ColorFiltered(child: this, colorFilter: colorFilter, key: key,);

  Widget title({Key? key, String title = '', required Color color,}) =>
    Title(child: this, key: key, title: title, color: color,);

  Widget animatedSwitcher({Key? key, required Duration duration, Duration? reverseDuration, Curve switchInCurve = Curves.linear, Curve switchOutCurve = Curves.linear, AnimatedSwitcherTransitionBuilder transitionBuilder = AnimatedSwitcher.defaultTransitionBuilder, AnimatedSwitcherLayoutBuilder layoutBuilder = AnimatedSwitcher.defaultLayoutBuilder,}) =>
    AnimatedSwitcher(child: this, key: key, duration: duration, reverseDuration: reverseDuration, switchInCurve: switchInCurve, switchOutCurve: switchOutCurve, transitionBuilder: transitionBuilder, layoutBuilder: layoutBuilder,);

  Widget tableCell({Key? key, TableCellVerticalAlignment? verticalAlignment,}) =>
    TableCell(child: this, key: key, verticalAlignment: verticalAlignment,);

  Widget snapshotWidget({Key? key, SnapshotMode mode = SnapshotMode.normal, SnapshotPainter painter = const _DefaultSnapshotPainter(), bool autoresize = false, required SnapshotController controller,}) =>
    SnapshotWidget(child: this, key: key, mode: mode, painter: painter, autoresize: autoresize, controller: controller,);

  Widget dualTransitionBuilder({Key? key, required Animation<double> animation, required AnimatedTransitionBuilder forwardBuilder, required AnimatedTransitionBuilder reverseBuilder,}) =>
    DualTransitionBuilder(child: this, key: key, animation: animation, forwardBuilder: forwardBuilder, reverseBuilder: reverseBuilder,);

  Widget visibility({Key? key, Widget replacement = const SizedBox.shrink(), bool visible = true, bool maintainState = false, bool maintainAnimation = false, bool maintainSize = false, bool maintainSemantics = false, bool maintainInteractivity = false,}) =>
    Visibility(child: this, key: key, replacement: replacement, visible: visible, maintainState: maintainState, maintainAnimation: maintainAnimation, maintainSize: maintainSize, maintainSemantics: maintainSemantics, maintainInteractivity: maintainInteractivity,);

  Widget visibilitymaintain({Key? key, bool visible = true,}) =>
    Visibility.maintain(child: this, key: key, visible: visible,);

  Widget annotatedRegion<T extends Object>({Key? key, required T value, bool sized = true,}) =>
    AnnotatedRegion(child: this, key: key, value: value, sized: sized,);

  Widget banner({Key? key, required String message, TextDirection? textDirection, required BannerLocation location, TextDirection? layoutDirection, Color color = _kColor, TextStyle textStyle = _kTextStyle, BoxShadow shadow = _kShadow,}) =>
    Banner(child: this, key: key, message: message, textDirection: textDirection, location: location, layoutDirection: layoutDirection, color: color, textStyle: textStyle, shadow: shadow,);

  Widget checkedModeBanner({Key? key,}) =>
    CheckedModeBanner(child: this, key: key,);

  Widget notificationListener<T extends Notification>({Key? key, NotificationListenerCallback<T>? onNotification,}) =>
    NotificationListener(child: this, key: key, onNotification: onNotification,);

  Widget sliverFloatingHeader({Key? key, AnimationStyle? animationStyle, FloatingHeaderSnapMode? snapMode,}) =>
    SliverFloatingHeader(child: this, key: key, animationStyle: animationStyle, snapMode: snapMode,);

  Widget view({Key? key, required FlutterView view, @Deprecated('Do not use. ' 'This parameter only exists to implement the deprecated RendererBinding.pipelineOwner property until it is removed. ' 'This feature was deprecated after v3.10.0-12.0.pre.') PipelineOwner? deprecatedDoNotUseWillBeRemovedWithoutNoticePipelineOwner, @Deprecated('Do not use. ' 'This parameter only exists to implement the deprecated RendererBinding.renderView property until it is removed. ' 'This feature was deprecated after v3.10.0-12.0.pre.') RenderView? deprecatedDoNotUseWillBeRemovedWithoutNoticeRenderView,}) =>
    View(child: this, key: key, view: view, deprecatedDoNotUseWillBeRemovedWithoutNoticePipelineOwner: deprecatedDoNotUseWillBeRemovedWithoutNoticePipelineOwner, deprecatedDoNotUseWillBeRemovedWithoutNoticeRenderView: deprecatedDoNotUseWillBeRemovedWithoutNoticeRenderView,);

  Widget rawView({Key? key, required FlutterView view, @Deprecated('Do not use. ' 'This parameter only exists to implement the deprecated RendererBinding.pipelineOwner property until it is removed. ' 'This feature was deprecated after v3.10.0-12.0.pre.') PipelineOwner? deprecatedDoNotUseWillBeRemovedWithoutNoticePipelineOwner, @Deprecated('Do not use. ' 'This parameter only exists to implement the deprecated RendererBinding.renderView property until it is removed. ' 'This feature was deprecated after v3.10.0-12.0.pre.') RenderView? deprecatedDoNotUseWillBeRemovedWithoutNoticeRenderView,}) =>
    RawView(child: this, key: key, view: view, deprecatedDoNotUseWillBeRemovedWithoutNoticePipelineOwner: deprecatedDoNotUseWillBeRemovedWithoutNoticePipelineOwner, deprecatedDoNotUseWillBeRemovedWithoutNoticeRenderView: deprecatedDoNotUseWillBeRemovedWithoutNoticeRenderView,);

  Widget viewAnchor({Key? key, Widget? view,}) =>
    ViewAnchor(child: this, key: key, view: view,);

  Widget renderObjectToWidgetAdapter<T extends RenderObject>({required RenderObjectWithChildMixin<T> container, String? debugShortDescription,}) =>
    RenderObjectToWidgetAdapter(child: this, container: container, debugShortDescription: debugShortDescription,);

  Widget lookupBoundary({Key? key,}) =>
    LookupBoundary(child: this, key: key,);

  Widget sliverResizingHeader({Key? key, Widget? minExtentPrototype, Widget? maxExtentPrototype,}) =>
    SliverResizingHeader(child: this, key: key, minExtentPrototype: minExtentPrototype, maxExtentPrototype: maxExtentPrototype,);

  Widget shortcuts({Key? key, required Map<ShortcutActivator, Intent> shortcuts, String? debugLabel, bool includeSemantics = true,}) =>
    Shortcuts(child: this, key: key, shortcuts: shortcuts, debugLabel: debugLabel, includeSemantics: includeSemantics,);

  Widget shortcutsmanager({Key? key, required ShortcutManager manager, String? debugLabel, bool includeSemantics = true,}) =>
    Shortcuts.manager(child: this, key: key, manager: manager, debugLabel: debugLabel, includeSemantics: includeSemantics,);

  Widget callbackShortcuts({Key? key, required Map<ShortcutActivator, VoidCallback> bindings,}) =>
    CallbackShortcuts(child: this, key: key, bindings: bindings,);

  Widget shortcutRegistrar({Key? key,}) =>
    ShortcutRegistrar(child: this, key: key,);

  Widget keyboardListener({Key? key, required FocusNode focusNode, bool autofocus = false, bool includeSemantics = true, ValueChanged<KeyEvent>? onKeyEvent,}) =>
    KeyboardListener(child: this, key: key, focusNode: focusNode, autofocus: autofocus, includeSemantics: includeSemantics, onKeyEvent: onKeyEvent,);

  Widget imageFiltered({Key? key, required ImageFilter imageFilter, bool enabled = true,}) =>
    ImageFiltered(child: this, key: key, imageFilter: imageFilter, enabled: enabled,);

  Widget scrollNotificationObserver({Key? key,}) =>
    ScrollNotificationObserver(child: this, key: key,);

  Widget sharedAppData({Key? key,}) =>
    SharedAppData(child: this, key: key,);

  Widget draggable<T extends Object>({Key? key, required Widget feedback, T? data, Axis? axis, Widget? childWhenDragging, Offset feedbackOffset = Offset.zero, DragAnchorStrategy dragAnchorStrategy = childDragAnchorStrategy, Axis? affinity, int? maxSimultaneousDrags, VoidCallback? onDragStarted, DragUpdateCallback? onDragUpdate, DraggableCanceledCallback? onDraggableCanceled, DragEndCallback? onDragEnd, VoidCallback? onDragCompleted, bool ignoringFeedbackSemantics = true, bool ignoringFeedbackPointer = true, bool rootOverlay = false, HitTestBehavior hitTestBehavior = HitTestBehavior.deferToChild, AllowedButtonsFilter? allowedButtonsFilter,}) =>
    Draggable(child: this, key: key, feedback: feedback, data: data, axis: axis, childWhenDragging: childWhenDragging, feedbackOffset: feedbackOffset, dragAnchorStrategy: dragAnchorStrategy, affinity: affinity, maxSimultaneousDrags: maxSimultaneousDrags, onDragStarted: onDragStarted, onDragUpdate: onDragUpdate, onDraggableCanceled: onDraggableCanceled, onDragEnd: onDragEnd, onDragCompleted: onDragCompleted, ignoringFeedbackSemantics: ignoringFeedbackSemantics, ignoringFeedbackPointer: ignoringFeedbackPointer, rootOverlay: rootOverlay, hitTestBehavior: hitTestBehavior, allowedButtonsFilter: allowedButtonsFilter,);

  Widget longPressDraggable<T extends Object>({Key? key, required Widget feedback, T? data, Axis? axis, Widget? childWhenDragging, Offset feedbackOffset = Offset.zero, DragAnchorStrategy dragAnchorStrategy = childDragAnchorStrategy, int? maxSimultaneousDrags, VoidCallback? onDragStarted, DragUpdateCallback? onDragUpdate, DraggableCanceledCallback? onDraggableCanceled, void Function(DraggableDetails)? onDragEnd, VoidCallback? onDragCompleted, bool hapticFeedbackOnStart = true, bool ignoringFeedbackSemantics = true, bool ignoringFeedbackPointer = true, Duration delay = kLongPressTimeout, AllowedButtonsFilter? allowedButtonsFilter, HitTestBehavior hitTestBehavior = HitTestBehavior.deferToChild, bool rootOverlay = false,}) =>
    LongPressDraggable(child: this, key: key, feedback: feedback, data: data, axis: axis, childWhenDragging: childWhenDragging, feedbackOffset: feedbackOffset, dragAnchorStrategy: dragAnchorStrategy, maxSimultaneousDrags: maxSimultaneousDrags, onDragStarted: onDragStarted, onDragUpdate: onDragUpdate, onDraggableCanceled: onDraggableCanceled, onDragEnd: onDragEnd, onDragCompleted: onDragCompleted, hapticFeedbackOnStart: hapticFeedbackOnStart, ignoringFeedbackSemantics: ignoringFeedbackSemantics, ignoringFeedbackPointer: ignoringFeedbackPointer, delay: delay, allowedButtonsFilter: allowedButtonsFilter, hitTestBehavior: hitTestBehavior, rootOverlay: rootOverlay,);

  Widget glowingOverscrollIndicator({Key? key, bool showLeading = true, bool showTrailing = true, required AxisDirection axisDirection, required Color color, ScrollNotificationPredicate notificationPredicate = defaultScrollNotificationPredicate,}) =>
    GlowingOverscrollIndicator(child: this, key: key, showLeading: showLeading, showTrailing: showTrailing, axisDirection: axisDirection, color: color, notificationPredicate: notificationPredicate,);

  Widget stretchingOverscrollIndicator({Key? key, required AxisDirection axisDirection, ScrollNotificationPredicate notificationPredicate = defaultScrollNotificationPredicate, Clip clipBehavior = Clip.hardEdge,}) =>
    StretchingOverscrollIndicator(child: this, key: key, axisDirection: axisDirection, notificationPredicate: notificationPredicate, clipBehavior: clipBehavior,);

  Widget hero({Key? key, required Object tag, CreateRectTween? createRectTween, HeroFlightShuttleBuilder? flightShuttleBuilder, HeroPlaceholderBuilder? placeholderBuilder, bool transitionOnUserGestures = false,}) =>
    Hero(child: this, key: key, tag: tag, createRectTween: createRectTween, flightShuttleBuilder: flightShuttleBuilder, placeholderBuilder: placeholderBuilder, transitionOnUserGestures: transitionOnUserGestures,);

  Widget heroMode({Key? key, bool enabled = true,}) =>
    HeroMode(child: this, key: key, enabled: enabled,);

  Widget sizeChangedLayoutNotifier({Key? key,}) =>
    SizeChangedLayoutNotifier(child: this, key: key,);

  Widget widgetInspector({Key? key, required InspectorSelectButtonBuilder selectButtonBuilder,}) =>
    WidgetInspector(child: this, key: key, selectButtonBuilder: selectButtonBuilder,);

  Widget automaticKeepAlive({Key? key,}) =>
    AutomaticKeepAlive(child: this, key: key,);

  Widget scrollConfiguration({Key? key, required ScrollBehavior behavior,}) =>
    ScrollConfiguration(child: this, key: key, behavior: behavior,);

  Widget iconTheme({Key? key, required IconThemeData data,}) =>
    IconTheme(child: this, key: key, data: data,);

  Widget semanticsDebugger({Key? key, TextStyle labelStyle = const TextStyle(color: Color(0xFF000000), fontSize: 10.0, height: 0.8),}) =>
    SemanticsDebugger(child: this, key: key, labelStyle: labelStyle,);

  Widget textSelectionGestureDetector({Key? key, VoidCallback? onTapTrackStart, VoidCallback? onTapTrackReset, GestureTapDragDownCallback? onTapDown, GestureForcePressStartCallback? onForcePressStart, GestureForcePressEndCallback? onForcePressEnd, GestureTapCallback? onSecondaryTap, GestureTapDownCallback? onSecondaryTapDown, GestureTapDragUpCallback? onSingleTapUp, GestureCancelCallback? onSingleTapCancel, GestureTapCallback? onUserTap, GestureLongPressStartCallback? onSingleLongTapStart, GestureLongPressMoveUpdateCallback? onSingleLongTapMoveUpdate, GestureLongPressEndCallback? onSingleLongTapEnd, GestureTapDragDownCallback? onDoubleTapDown, GestureTapDragDownCallback? onTripleTapDown, GestureTapDragStartCallback? onDragSelectionStart, GestureTapDragUpdateCallback? onDragSelectionUpdate, GestureTapDragEndCallback? onDragSelectionEnd, bool onUserTapAlwaysCalled = false, HitTestBehavior? behavior,}) =>
    TextSelectionGestureDetector(child: this, key: key, onTapTrackStart: onTapTrackStart, onTapTrackReset: onTapTrackReset, onTapDown: onTapDown, onForcePressStart: onForcePressStart, onForcePressEnd: onForcePressEnd, onSecondaryTap: onSecondaryTap, onSecondaryTapDown: onSecondaryTapDown, onSingleTapUp: onSingleTapUp, onSingleTapCancel: onSingleTapCancel, onUserTap: onUserTap, onSingleLongTapStart: onSingleLongTapStart, onSingleLongTapMoveUpdate: onSingleLongTapMoveUpdate, onSingleLongTapEnd: onSingleLongTapEnd, onDoubleTapDown: onDoubleTapDown, onTripleTapDown: onTripleTapDown, onDragSelectionStart: onDragSelectionStart, onDragSelectionUpdate: onDragSelectionUpdate, onDragSelectionEnd: onDragSelectionEnd, onUserTapAlwaysCalled: onUserTapAlwaysCalled, behavior: behavior,);

  Widget tickerMode({Key? key, required bool enabled,}) =>
    TickerMode(child: this, key: key, enabled: enabled,);

  Widget restorationScope({Key? key, required String restorationId,}) =>
    RestorationScope(child: this, key: key, restorationId: restorationId,);

  Widget unmanagedRestorationScope({Key? key, RestorationBucket? bucket,}) =>
    UnmanagedRestorationScope(child: this, key: key, bucket: bucket,);

  Widget rootRestorationScope({Key? key, required String restorationId,}) =>
    RootRestorationScope(child: this, key: key, restorationId: restorationId,);

  Widget focus({Key? key, FocusNode? focusNode, FocusNode? parentNode, bool autofocus = false, ValueChanged<bool>? onFocusChange, FocusOnKeyEventCallback? onKeyEvent, @Deprecated('Use onKeyEvent instead. ' 'This feature was deprecated after v3.18.0-2.0.pre.') FocusOnKeyCallback? onKey, bool? canRequestFocus, bool? skipTraversal, bool? descendantsAreFocusable, bool? descendantsAreTraversable, bool includeSemantics = true, String? debugLabel,}) =>
    Focus(child: this, key: key, focusNode: focusNode, parentNode: parentNode, autofocus: autofocus, onFocusChange: onFocusChange, onKeyEvent: onKeyEvent, onKey: onKey, canRequestFocus: canRequestFocus, skipTraversal: skipTraversal, descendantsAreFocusable: descendantsAreFocusable, descendantsAreTraversable: descendantsAreTraversable, includeSemantics: includeSemantics, debugLabel: debugLabel,);

  Widget focuswithExternalFocusNode({Key? key, required FocusNode focusNode, FocusNode? parentNode, ValueChanged<bool>? onFocusChange,}) =>
    Focus.withExternalFocusNode(child: this, key: key, focusNode: focusNode, parentNode: parentNode, onFocusChange: onFocusChange,);

  Widget focusScope({Key? key, FocusScopeNode? node, FocusNode? parentNode, bool autofocus = false, ValueChanged<bool>? onFocusChange, bool? canRequestFocus, bool? skipTraversal, String? debugLabel, bool includeSemantics = true, bool? descendantsAreFocusable, bool? descendantsAreTraversable,}) =>
    FocusScope(child: this, key: key, node: node, parentNode: parentNode, autofocus: autofocus, onFocusChange: onFocusChange, canRequestFocus: canRequestFocus, skipTraversal: skipTraversal, debugLabel: debugLabel, includeSemantics: includeSemantics, descendantsAreFocusable: descendantsAreFocusable, descendantsAreTraversable: descendantsAreTraversable,);

  Widget focusScopewithExternalFocusNode({Key? key, required FocusScopeNode focusScopeNode, FocusNode? parentNode, ValueChanged<bool>? onFocusChange,}) =>
    FocusScope.withExternalFocusNode(child: this, key: key, focusScopeNode: focusScopeNode, parentNode: parentNode, onFocusChange: onFocusChange,);

  Widget excludeFocus({Key? key, bool excluding = true,}) =>
    ExcludeFocus(child: this, key: key, excluding: excluding,);

  Widget pinnedHeaderSliver({Key? key,}) =>
    PinnedHeaderSliver(child: this, key: key,);

  Widget interactiveViewer({Key? key, Clip clipBehavior = Clip.hardEdge, PanAxis panAxis = PanAxis.free, EdgeInsets boundaryMargin = EdgeInsets.zero, bool constrained = true, double maxScale = 2.5, double minScale = 0.8, double interactionEndFrictionCoefficient = _kDrag, GestureScaleEndCallback? onInteractionEnd, GestureScaleStartCallback? onInteractionStart, GestureScaleUpdateCallback? onInteractionUpdate, bool panEnabled = true, bool scaleEnabled = true, double scaleFactor = kDefaultMouseScrollToScaleFactor, TransformationController? transformationController, Alignment? alignment, bool trackpadScrollCausesScale = false,}) =>
    InteractiveViewer(child: this, key: key, clipBehavior: clipBehavior, panAxis: panAxis, boundaryMargin: boundaryMargin, constrained: constrained, maxScale: maxScale, minScale: minScale, interactionEndFrictionCoefficient: interactionEndFrictionCoefficient, onInteractionEnd: onInteractionEnd, onInteractionStart: onInteractionStart, onInteractionUpdate: onInteractionUpdate, panEnabled: panEnabled, scaleEnabled: scaleEnabled, scaleFactor: scaleFactor, transformationController: transformationController, alignment: alignment, trackpadScrollCausesScale: trackpadScrollCausesScale,);

  Widget displayFeatureSubScreen({Key? key, Offset? anchorPoint,}) =>
    DisplayFeatureSubScreen(child: this, key: key, anchorPoint: anchorPoint,);

  Widget autofillGroup({Key? key, AutofillContextAction onDisposeAction = AutofillContextAction.commit,}) =>
    AutofillGroup(child: this, key: key, onDisposeAction: onDisposeAction,);

  Widget keepAlive({Key? key, required bool keepAlive,}) =>
    KeepAlive(child: this, key: key, keepAlive: keepAlive,);

  Widget rawMagnifier({Key? key, MagnifierDecoration decoration = const MagnifierDecoration(), Clip clipBehavior = Clip.none, Offset focalPointOffset = Offset.zero, double magnificationScale = 1, required Size size,}) =>
    RawMagnifier(child: this, key: key, decoration: decoration, clipBehavior: clipBehavior, focalPointOffset: focalPointOffset, magnificationScale: magnificationScale, size: size,);

  Widget platformMenuBar({Key? key, required List<PlatformMenuItem> menus,}) =>
    PlatformMenuBar(child: this, key: key, menus: menus,);

  Widget dismissible({required Key key, Widget? background, Widget? secondaryBackground, ConfirmDismissCallback? confirmDismiss, VoidCallback? onResize, DismissUpdateCallback? onUpdate, DismissDirectionCallback? onDismissed, DismissDirection direction = DismissDirection.horizontal, Duration? resizeDuration = const Duration(milliseconds: 300), Map<DismissDirection, double> dismissThresholds = const <DismissDirection, double>{}, Duration movementDuration = const Duration(milliseconds: 200), double crossAxisEndOffset = 0.0, DragStartBehavior dragStartBehavior = DragStartBehavior.start, HitTestBehavior behavior = HitTestBehavior.opaque,}) =>
    Dismissible(child: this, key: key, background: background, secondaryBackground: secondaryBackground, confirmDismiss: confirmDismiss, onResize: onResize, onUpdate: onUpdate, onDismissed: onDismissed, direction: direction, resizeDuration: resizeDuration, dismissThresholds: dismissThresholds, movementDuration: movementDuration, crossAxisEndOffset: crossAxisEndOffset, dragStartBehavior: dragStartBehavior, behavior: behavior,);

  Widget willPopScope({Key? key, required WillPopCallback onWillPop,}) =>
    WillPopScope(child: this, key: key, onWillPop: onWillPop,);

  Widget safeArea({Key? key, bool left = true, bool top = true, bool right = true, bool bottom = true, EdgeInsets minimum = EdgeInsets.zero, bool maintainBottomViewPadding = false,}) =>
    SafeArea(child: this, key: key, left: left, top: top, right: right, bottom: bottom, minimum: minimum, maintainBottomViewPadding: maintainBottomViewPadding,);

  Widget rawScrollbar({Key? key, ScrollController? controller, bool? thumbVisibility, OutlinedBorder? shape, Radius? radius, double? thickness, Color? thumbColor, double minThumbLength = _kMinThumbExtent, double? minOverscrollLength, bool? trackVisibility, Radius? trackRadius, Color? trackColor, Color? trackBorderColor, Duration fadeDuration = _kScrollbarFadeDuration, Duration timeToFade = _kScrollbarTimeToFade, Duration pressDuration = Duration.zero, ScrollNotificationPredicate notificationPredicate = defaultScrollNotificationPredicate, bool? interactive, ScrollbarOrientation? scrollbarOrientation, double mainAxisMargin = 0.0, double crossAxisMargin = 0.0, EdgeInsets? padding,}) =>
    RawScrollbar(child: this, key: key, controller: controller, thumbVisibility: thumbVisibility, shape: shape, radius: radius, thickness: thickness, thumbColor: thumbColor, minThumbLength: minThumbLength, minOverscrollLength: minOverscrollLength, trackVisibility: trackVisibility, trackRadius: trackRadius, trackColor: trackColor, trackBorderColor: trackBorderColor, fadeDuration: fadeDuration, timeToFade: timeToFade, pressDuration: pressDuration, notificationPredicate: notificationPredicate, interactive: interactive, scrollbarOrientation: scrollbarOrientation, mainAxisMargin: mainAxisMargin, crossAxisMargin: crossAxisMargin, padding: padding,);

  Widget autocompleteHighlightedOption({Key? key, required ValueNotifier<int> highlightIndexNotifier,}) =>
    AutocompleteHighlightedOption(child: this, key: key, highlightIndexNotifier: highlightIndexNotifier,);

  Widget overlayPortal({Key? key, required OverlayPortalController controller, required WidgetBuilder overlayChildBuilder,}) =>
    OverlayPortal(child: this, key: key, controller: controller, overlayChildBuilder: overlayChildBuilder,);

  Widget overlayPortaltargetsRootOverlay({Key? key, required OverlayPortalController controller, required WidgetBuilder overlayChildBuilder,}) =>
    OverlayPortal.targetsRootOverlay(child: this, key: key, controller: controller, overlayChildBuilder: overlayChildBuilder,);

  Widget defaultSelectionStyle({Key? key, Color? cursorColor, Color? selectionColor, MouseCursor? mouseCursor,}) =>
    DefaultSelectionStyle(child: this, key: key, cursorColor: cursorColor, selectionColor: selectionColor, mouseCursor: mouseCursor,);

  Widget rawKeyboardListener({Key? key, required FocusNode focusNode, bool autofocus = false, bool includeSemantics = true, ValueChanged<RawKeyEvent>? onKey,}) =>
    RawKeyboardListener(child: this, key: key, focusNode: focusNode, autofocus: autofocus, includeSemantics: includeSemantics, onKey: onKey,);

  Widget localizations({Key? key, required Locale locale, required List<LocalizationsDelegate<dynamic>> delegates,}) =>
    Localizations(child: this, key: key, locale: locale, delegates: delegates,);

  Widget localizationsoverride({Key? key, required BuildContext context, Locale? locale, List<LocalizationsDelegate<dynamic>>? delegates,}) =>
    Localizations.override(child: this, key: key, context: context, locale: locale, delegates: delegates,);

  Widget selectableRegion({Key? key, SelectableRegionContextMenuBuilder? contextMenuBuilder, required FocusNode focusNode, required TextSelectionControls selectionControls, TextMagnifierConfiguration magnifierConfiguration = TextMagnifierConfiguration.disabled, ValueChanged<SelectedContent?>? onSelectionChanged,}) =>
    SelectableRegion(child: this, key: key, contextMenuBuilder: contextMenuBuilder, focusNode: focusNode, selectionControls: selectionControls, magnifierConfiguration: magnifierConfiguration, onSelectionChanged: onSelectionChanged,);

  Widget sliverFillRemaining({Key? key, bool hasScrollBody = true, bool fillOverscroll = false,}) =>
    SliverFillRemaining(child: this, key: key, hasScrollBody: hasScrollBody, fillOverscroll: fillOverscroll,);

  Widget animatedSize({Key? key, AlignmentGeometry alignment = Alignment.center, Curve curve = Curves.linear, required Duration duration, Duration? reverseDuration, Clip clipBehavior = Clip.hardEdge, VoidCallback? onEnd,}) =>
    AnimatedSize(child: this, key: key, alignment: alignment, curve: curve, duration: duration, reverseDuration: reverseDuration, clipBehavior: clipBehavior, onEnd: onEnd,);

  Widget rootWidget({Key? key, String? debugShortDescription,}) =>
    RootWidget(child: this, key: key, debugShortDescription: debugShortDescription,);

}

/// Converting a List<Widget> into a multi-child widget that takes a children or slivers parameter.
extension MultiChildFlutterWidgetSkewer on List<Widget> {
  Widget cupertinoDesktopTextSelectionToolbar({Key? key, required Offset anchor,}) =>
    CupertinoDesktopTextSelectionToolbar(children: this, key: key, anchor: anchor,);

  Widget cupertinoPicker({Key? key, double diameterRatio = _kDefaultDiameterRatio, Color? backgroundColor, double offAxisFraction = 0.0, bool useMagnifier = false, double magnification = 1.0, FixedExtentScrollController? scrollController, double squeeze = _kSqueeze, required double itemExtent, required ValueChanged<int> onSelectedItemChanged, Widget? selectionOverlay = const CupertinoPickerDefaultSelectionOverlay(), bool looping = false,}) =>
    CupertinoPicker(children: this, key: key, diameterRatio: diameterRatio, backgroundColor: backgroundColor, offAxisFraction: offAxisFraction, useMagnifier: useMagnifier, magnification: magnification, scrollController: scrollController, squeeze: squeeze, itemExtent: itemExtent, onSelectedItemChanged: onSelectedItemChanged, selectionOverlay: selectionOverlay, looping: looping,);

  Widget cupertinoListSection({Key? key, Widget? header, Widget? footer, EdgeInsetsGeometry margin = _kDefaultRowsMargin, Color backgroundColor = CupertinoColors.systemGroupedBackground, BoxDecoration? decoration, Clip clipBehavior = Clip.none, double dividerMargin = _kBaseDividerMargin, double? additionalDividerMargin, double? topMargin = _kMarginTop, bool hasLeading = true, Color? separatorColor,}) =>
    CupertinoListSection(children: this, key: key, header: header, footer: footer, margin: margin, backgroundColor: backgroundColor, decoration: decoration, clipBehavior: clipBehavior, dividerMargin: dividerMargin, additionalDividerMargin: additionalDividerMargin, topMargin: topMargin, hasLeading: hasLeading, separatorColor: separatorColor,);

  Widget cupertinoListSectioninsetGrouped({Key? key, Widget? header, Widget? footer, EdgeInsetsGeometry? margin, Color backgroundColor = CupertinoColors.systemGroupedBackground, BoxDecoration? decoration, Clip clipBehavior = Clip.hardEdge, double dividerMargin = _kInsetDividerMargin, double? additionalDividerMargin, double? topMargin, bool hasLeading = true, Color? separatorColor,}) =>
    CupertinoListSection.insetGrouped(children: this, key: key, header: header, footer: footer, margin: margin, backgroundColor: backgroundColor, decoration: decoration, clipBehavior: clipBehavior, dividerMargin: dividerMargin, additionalDividerMargin: additionalDividerMargin, topMargin: topMargin, hasLeading: hasLeading, separatorColor: separatorColor,);

  Widget cupertinoAdaptiveTextSelectionToolbar({Key? key, required TextSelectionToolbarAnchors anchors,}) =>
    CupertinoAdaptiveTextSelectionToolbar(children: this, key: key, anchors: anchors,);

  Widget cupertinoFormSection({Key? key, Widget? header, Widget? footer, EdgeInsetsGeometry margin = EdgeInsets.zero, Color backgroundColor = CupertinoColors.systemGroupedBackground, BoxDecoration? decoration, Clip clipBehavior = Clip.none,}) =>
    CupertinoFormSection(children: this, key: key, header: header, footer: footer, margin: margin, backgroundColor: backgroundColor, decoration: decoration, clipBehavior: clipBehavior,);

  Widget cupertinoFormSectioninsetGrouped({Key? key, Widget? header, Widget? footer, EdgeInsetsGeometry margin = _kFormDefaultInsetGroupedRowsMargin, Color backgroundColor = CupertinoColors.systemGroupedBackground, BoxDecoration? decoration, Clip clipBehavior = Clip.none,}) =>
    CupertinoFormSection.insetGrouped(children: this, key: key, header: header, footer: footer, margin: margin, backgroundColor: backgroundColor, decoration: decoration, clipBehavior: clipBehavior,);

  Widget aboutDialog({Key? key, String? applicationName, String? applicationVersion, Widget? applicationIcon, String? applicationLegalese,}) =>
    AboutDialog(children: this, key: key, applicationName: applicationName, applicationVersion: applicationVersion, applicationIcon: applicationIcon, applicationLegalese: applicationLegalese,);

  Widget buttonBar({Key? key, MainAxisAlignment? alignment, MainAxisSize? mainAxisSize, ButtonTextTheme? buttonTextTheme, double? buttonMinWidth, double? buttonHeight, EdgeInsetsGeometry? buttonPadding, bool? buttonAlignedDropdown, ButtonBarLayoutBehavior? layoutBehavior, VerticalDirection? overflowDirection, double? overflowButtonSpacing,}) =>
    ButtonBar(children: this, key: key, alignment: alignment, mainAxisSize: mainAxisSize, buttonTextTheme: buttonTextTheme, buttonMinWidth: buttonMinWidth, buttonHeight: buttonHeight, buttonPadding: buttonPadding, buttonAlignedDropdown: buttonAlignedDropdown, layoutBehavior: layoutBehavior, overflowDirection: overflowDirection, overflowButtonSpacing: overflowButtonSpacing,);

  Widget reorderableListView({Key? key, required ReorderCallback onReorder, void Function(int index)? onReorderStart, void Function(int index)? onReorderEnd, double? itemExtent, ItemExtentBuilder? itemExtentBuilder, Widget? prototypeItem, ReorderItemProxyDecorator? proxyDecorator, bool buildDefaultDragHandles = true, EdgeInsets? padding, Widget? header, Widget? footer, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? scrollController, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, double anchor = 0.0, double? cacheExtent, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge, double? autoScrollerVelocityScalar,}) =>
    ReorderableListView(children: this, key: key, onReorder: onReorder, onReorderStart: onReorderStart, onReorderEnd: onReorderEnd, itemExtent: itemExtent, itemExtentBuilder: itemExtentBuilder, prototypeItem: prototypeItem, proxyDecorator: proxyDecorator, buildDefaultDragHandles: buildDefaultDragHandles, padding: padding, header: header, footer: footer, scrollDirection: scrollDirection, reverse: reverse, scrollController: scrollController, primary: primary, physics: physics, shrinkWrap: shrinkWrap, anchor: anchor, cacheExtent: cacheExtent, dragStartBehavior: dragStartBehavior, keyboardDismissBehavior: keyboardDismissBehavior, restorationId: restorationId, clipBehavior: clipBehavior, autoScrollerVelocityScalar: autoScrollerVelocityScalar,);

  Widget desktopTextSelectionToolbar({Key? key, required Offset anchor,}) =>
    DesktopTextSelectionToolbar(children: this, key: key, anchor: anchor,);

  Widget navigationDrawer({Key? key, Color? backgroundColor, Color? shadowColor, Color? surfaceTintColor, double? elevation, Color? indicatorColor, ShapeBorder? indicatorShape, ValueChanged<int>? onDestinationSelected, int? selectedIndex = 0, EdgeInsetsGeometry tilePadding = const EdgeInsets.symmetric(horizontal: 12.0),}) =>
    NavigationDrawer(children: this, key: key, backgroundColor: backgroundColor, shadowColor: shadowColor, surfaceTintColor: surfaceTintColor, elevation: elevation, indicatorColor: indicatorColor, indicatorShape: indicatorShape, onDestinationSelected: onDestinationSelected, selectedIndex: selectedIndex, tilePadding: tilePadding,);

  Widget carouselView({Key? key, EdgeInsets? padding, Color? backgroundColor, double? elevation, ShapeBorder? shape, WidgetStateProperty<Color?>? overlayColor, bool itemSnapping = false, double shrinkExtent = 0.0, CarouselController? controller, Axis scrollDirection = Axis.horizontal, bool reverse = false, ValueChanged<int>? onTap, bool enableSplash = true, required double itemExtent,}) =>
    CarouselView(children: this, key: key, padding: padding, backgroundColor: backgroundColor, elevation: elevation, shape: shape, overlayColor: overlayColor, itemSnapping: itemSnapping, shrinkExtent: shrinkExtent, controller: controller, scrollDirection: scrollDirection, reverse: reverse, onTap: onTap, enableSplash: enableSplash, itemExtent: itemExtent,);

  Widget carouselViewweighted({Key? key, EdgeInsets? padding, Color? backgroundColor, double? elevation, ShapeBorder? shape, WidgetStateProperty<Color?>? overlayColor, bool itemSnapping = false, double shrinkExtent = 0.0, CarouselController? controller, Axis scrollDirection = Axis.horizontal, bool reverse = false, bool consumeMaxWeight = true, ValueChanged<int>? onTap, bool enableSplash = true, required List<int> flexWeights,}) =>
    CarouselView.weighted(children: this, key: key, padding: padding, backgroundColor: backgroundColor, elevation: elevation, shape: shape, overlayColor: overlayColor, itemSnapping: itemSnapping, shrinkExtent: shrinkExtent, controller: controller, scrollDirection: scrollDirection, reverse: reverse, consumeMaxWeight: consumeMaxWeight, onTap: onTap, enableSplash: enableSplash, flexWeights: flexWeights,);

  Widget menuBar({Key? key, MenuStyle? style, Clip clipBehavior = Clip.none, MenuController? controller,}) =>
    MenuBar(children: this, key: key, style: style, clipBehavior: clipBehavior, controller: controller,);

  Widget simpleDialog({Key? key, Widget? title, EdgeInsetsGeometry titlePadding = const EdgeInsets.fromLTRB(24.0, 24.0, 24.0, 0.0), TextStyle? titleTextStyle, EdgeInsetsGeometry contentPadding = const EdgeInsets.fromLTRB(0.0, 12.0, 0.0, 16.0), Color? backgroundColor, double? elevation, Color? shadowColor, Color? surfaceTintColor, String? semanticLabel, EdgeInsets? insetPadding, Clip? clipBehavior, ShapeBorder? shape, AlignmentGeometry? alignment,}) =>
    SimpleDialog(children: this, key: key, title: title, titlePadding: titlePadding, titleTextStyle: titleTextStyle, contentPadding: contentPadding, backgroundColor: backgroundColor, elevation: elevation, shadowColor: shadowColor, surfaceTintColor: surfaceTintColor, semanticLabel: semanticLabel, insetPadding: insetPadding, clipBehavior: clipBehavior, shape: shape, alignment: alignment,);

  Widget tabBarView({Key? key, TabController? controller, ScrollPhysics? physics, DragStartBehavior dragStartBehavior = DragStartBehavior.start, double viewportFraction = 1.0, Clip clipBehavior = Clip.hardEdge,}) =>
    TabBarView(children: this, key: key, controller: controller, physics: physics, dragStartBehavior: dragStartBehavior, viewportFraction: viewportFraction, clipBehavior: clipBehavior,);

  Widget expansionTile({Key? key, Widget? leading, required Widget title, Widget? subtitle, ValueChanged<bool>? onExpansionChanged, Widget? trailing, bool showTrailingIcon = true, bool initiallyExpanded = false, bool maintainState = false, EdgeInsetsGeometry? tilePadding, CrossAxisAlignment? expandedCrossAxisAlignment, Alignment? expandedAlignment, EdgeInsetsGeometry? childrenPadding, Color? backgroundColor, Color? collapsedBackgroundColor, Color? textColor, Color? collapsedTextColor, Color? iconColor, Color? collapsedIconColor, ShapeBorder? shape, ShapeBorder? collapsedShape, Clip? clipBehavior, ListTileControlAffinity? controlAffinity, ExpansionTileController? controller, bool? dense, VisualDensity? visualDensity, double? minTileHeight, bool? enableFeedback = true, bool enabled = true, AnimationStyle? expansionAnimationStyle, bool internalAddSemanticForOnTap = false,}) =>
    ExpansionTile(children: this, key: key, leading: leading, title: title, subtitle: subtitle, onExpansionChanged: onExpansionChanged, trailing: trailing, showTrailingIcon: showTrailingIcon, initiallyExpanded: initiallyExpanded, maintainState: maintainState, tilePadding: tilePadding, expandedCrossAxisAlignment: expandedCrossAxisAlignment, expandedAlignment: expandedAlignment, childrenPadding: childrenPadding, backgroundColor: backgroundColor, collapsedBackgroundColor: collapsedBackgroundColor, textColor: textColor, collapsedTextColor: collapsedTextColor, iconColor: iconColor, collapsedIconColor: collapsedIconColor, shape: shape, collapsedShape: collapsedShape, clipBehavior: clipBehavior, controlAffinity: controlAffinity, controller: controller, dense: dense, visualDensity: visualDensity, minTileHeight: minTileHeight, enableFeedback: enableFeedback, enabled: enabled, expansionAnimationStyle: expansionAnimationStyle, internalAddSemanticForOnTap: internalAddSemanticForOnTap,);

  Widget adaptiveTextSelectionToolbar({Key? key, required TextSelectionToolbarAnchors anchors,}) =>
    AdaptiveTextSelectionToolbar(children: this, key: key, anchors: anchors,);

  Widget toggleButtons({Key? key, required List<bool> isSelected, void Function(int index)? onPressed, MouseCursor? mouseCursor, MaterialTapTargetSize? tapTargetSize, TextStyle? textStyle, BoxConstraints? constraints, Color? color, Color? selectedColor, Color? disabledColor, Color? fillColor, Color? focusColor, Color? highlightColor, Color? hoverColor, Color? splashColor, List<FocusNode>? focusNodes, bool renderBorder = true, Color? borderColor, Color? selectedBorderColor, Color? disabledBorderColor, BorderRadius? borderRadius, double? borderWidth, Axis direction = Axis.horizontal, VerticalDirection verticalDirection = VerticalDirection.down,}) =>
    ToggleButtons(children: this, key: key, isSelected: isSelected, onPressed: onPressed, mouseCursor: mouseCursor, tapTargetSize: tapTargetSize, textStyle: textStyle, constraints: constraints, color: color, selectedColor: selectedColor, disabledColor: disabledColor, fillColor: fillColor, focusColor: focusColor, highlightColor: highlightColor, hoverColor: hoverColor, splashColor: splashColor, focusNodes: focusNodes, renderBorder: renderBorder, borderColor: borderColor, selectedBorderColor: selectedBorderColor, disabledBorderColor: disabledBorderColor, borderRadius: borderRadius, borderWidth: borderWidth, direction: direction, verticalDirection: verticalDirection,);

  Widget customMultiChildLayout({Key? key, required MultiChildLayoutDelegate delegate,}) =>
    CustomMultiChildLayout(children: this, key: key, delegate: delegate,);

  Widget listBody({Key? key, Axis mainAxis = Axis.vertical, bool reverse = false,}) =>
    ListBody(children: this, key: key, mainAxis: mainAxis, reverse: reverse,);

  Widget stack({Key? key, AlignmentGeometry alignment = AlignmentDirectional.topStart, TextDirection? textDirection, StackFit fit = StackFit.loose, Clip clipBehavior = Clip.hardEdge,}) =>
    Stack(children: this, key: key, alignment: alignment, textDirection: textDirection, fit: fit, clipBehavior: clipBehavior,);

  Widget indexedStack({Key? key, AlignmentGeometry alignment = AlignmentDirectional.topStart, TextDirection? textDirection, Clip clipBehavior = Clip.hardEdge, StackFit sizing = StackFit.loose, int? index = 0,}) =>
    IndexedStack(children: this, key: key, alignment: alignment, textDirection: textDirection, clipBehavior: clipBehavior, sizing: sizing, index: index,);

  Widget flex({Key? key, required Axis direction, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, Clip clipBehavior = Clip.none, double spacing = 0.0,}) =>
    Flex(children: this, key: key, direction: direction, mainAxisAlignment: mainAxisAlignment, mainAxisSize: mainAxisSize, crossAxisAlignment: crossAxisAlignment, textDirection: textDirection, verticalDirection: verticalDirection, textBaseline: textBaseline, clipBehavior: clipBehavior, spacing: spacing,);

  Widget row({Key? key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, double spacing = 0.0,}) =>
    Row(children: this, key: key, mainAxisAlignment: mainAxisAlignment, mainAxisSize: mainAxisSize, crossAxisAlignment: crossAxisAlignment, textDirection: textDirection, verticalDirection: verticalDirection, textBaseline: textBaseline, spacing: spacing,);

  Widget column({Key? key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, double spacing = 0.0,}) =>
    Column(children: this, key: key, mainAxisAlignment: mainAxisAlignment, mainAxisSize: mainAxisSize, crossAxisAlignment: crossAxisAlignment, textDirection: textDirection, verticalDirection: verticalDirection, textBaseline: textBaseline, spacing: spacing,);

  Widget wrap({Key? key, Axis direction = Axis.horizontal, WrapAlignment alignment = WrapAlignment.start, double spacing = 0.0, WrapAlignment runAlignment = WrapAlignment.start, double runSpacing = 0.0, WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, Clip clipBehavior = Clip.none,}) =>
    Wrap(children: this, key: key, direction: direction, alignment: alignment, spacing: spacing, runAlignment: runAlignment, runSpacing: runSpacing, crossAxisAlignment: crossAxisAlignment, textDirection: textDirection, verticalDirection: verticalDirection, clipBehavior: clipBehavior,);

  Widget flow({Key? key, required FlowDelegate delegate, Clip clipBehavior = Clip.hardEdge,}) =>
    Flow(children: this, key: key, delegate: delegate, clipBehavior: clipBehavior,);

  Widget flowunwrapped({Key? key, required FlowDelegate delegate, Clip clipBehavior = Clip.hardEdge,}) =>
    Flow.unwrapped(children: this, key: key, delegate: delegate, clipBehavior: clipBehavior,);

  Widget nestedScrollViewViewport({Key? key, AxisDirection axisDirection = AxisDirection.down, AxisDirection? crossAxisDirection, double anchor = 0.0, required ViewportOffset offset, Key? center, required SliverOverlapAbsorberHandle handle, Clip clipBehavior = Clip.hardEdge,}) =>
    NestedScrollViewViewport(slivers: this, key: key, axisDirection: axisDirection, crossAxisDirection: crossAxisDirection, anchor: anchor, offset: offset, center: center, handle: handle, clipBehavior: clipBehavior,);

  Widget sliverPrototypeExtentListlist({Key? key, required Widget prototypeItem, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true,}) =>
    SliverPrototypeExtentList.list(children: this, key: key, prototypeItem: prototypeItem, addAutomaticKeepAlives: addAutomaticKeepAlives, addRepaintBoundaries: addRepaintBoundaries, addSemanticIndexes: addSemanticIndexes,);

  Widget pageView({Key? key, Axis scrollDirection = Axis.horizontal, bool reverse = false, PageController? controller, ScrollPhysics? physics, bool pageSnapping = true, ValueChanged<int>? onPageChanged, DragStartBehavior dragStartBehavior = DragStartBehavior.start, bool allowImplicitScrolling = false, String? restorationId, Clip clipBehavior = Clip.hardEdge, HitTestBehavior hitTestBehavior = HitTestBehavior.opaque, ScrollBehavior? scrollBehavior, bool padEnds = true,}) =>
    PageView(children: this, key: key, scrollDirection: scrollDirection, reverse: reverse, controller: controller, physics: physics, pageSnapping: pageSnapping, onPageChanged: onPageChanged, dragStartBehavior: dragStartBehavior, allowImplicitScrolling: allowImplicitScrolling, restorationId: restorationId, clipBehavior: clipBehavior, hitTestBehavior: hitTestBehavior, scrollBehavior: scrollBehavior, padEnds: padEnds,);

  Widget viewport({Key? key, AxisDirection axisDirection = AxisDirection.down, AxisDirection? crossAxisDirection, double anchor = 0.0, required ViewportOffset offset, Key? center, double? cacheExtent, CacheExtentStyle cacheExtentStyle = CacheExtentStyle.pixel, Clip clipBehavior = Clip.hardEdge,}) =>
    Viewport(slivers: this, key: key, axisDirection: axisDirection, crossAxisDirection: crossAxisDirection, anchor: anchor, offset: offset, center: center, cacheExtent: cacheExtent, cacheExtentStyle: cacheExtentStyle, clipBehavior: clipBehavior,);

  Widget shrinkWrappingViewport({Key? key, AxisDirection axisDirection = AxisDirection.down, AxisDirection? crossAxisDirection, required ViewportOffset offset, Clip clipBehavior = Clip.hardEdge,}) =>
    ShrinkWrappingViewport(slivers: this, key: key, axisDirection: axisDirection, crossAxisDirection: crossAxisDirection, offset: offset, clipBehavior: clipBehavior,);

  Widget overflowBar({Key? key, double spacing = 0.0, MainAxisAlignment? alignment, double overflowSpacing = 0.0, OverflowBarAlignment overflowAlignment = OverflowBarAlignment.start, VerticalDirection overflowDirection = VerticalDirection.down, TextDirection? textDirection,}) =>
    OverflowBar(children: this, key: key, spacing: spacing, alignment: alignment, overflowSpacing: overflowSpacing, overflowAlignment: overflowAlignment, overflowDirection: overflowDirection, textDirection: textDirection,);

  Widget listWheelScrollView({Key? key, ScrollController? controller, ScrollPhysics? physics, double diameterRatio = RenderListWheelViewport.defaultDiameterRatio, double perspective = RenderListWheelViewport.defaultPerspective, double offAxisFraction = 0.0, bool useMagnifier = false, double magnification = 1.0, double overAndUnderCenterOpacity = 1.0, required double itemExtent, double squeeze = 1.0, ValueChanged<int>? onSelectedItemChanged, bool renderChildrenOutsideViewport = false, Clip clipBehavior = Clip.hardEdge, HitTestBehavior hitTestBehavior = HitTestBehavior.opaque, String? restorationId, ScrollBehavior? scrollBehavior, DragStartBehavior dragStartBehavior = DragStartBehavior.start,}) =>
    ListWheelScrollView(children: this, key: key, controller: controller, physics: physics, diameterRatio: diameterRatio, perspective: perspective, offAxisFraction: offAxisFraction, useMagnifier: useMagnifier, magnification: magnification, overAndUnderCenterOpacity: overAndUnderCenterOpacity, itemExtent: itemExtent, squeeze: squeeze, onSelectedItemChanged: onSelectedItemChanged, renderChildrenOutsideViewport: renderChildrenOutsideViewport, clipBehavior: clipBehavior, hitTestBehavior: hitTestBehavior, restorationId: restorationId, scrollBehavior: scrollBehavior, dragStartBehavior: dragStartBehavior,);

  Widget sliverListlist({Key? key, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true,}) =>
    SliverList.list(children: this, key: key, addAutomaticKeepAlives: addAutomaticKeepAlives, addRepaintBoundaries: addRepaintBoundaries, addSemanticIndexes: addSemanticIndexes,);

  Widget sliverFixedExtentListlist({Key? key, required double itemExtent, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true,}) =>
    SliverFixedExtentList.list(children: this, key: key, itemExtent: itemExtent, addAutomaticKeepAlives: addAutomaticKeepAlives, addRepaintBoundaries: addRepaintBoundaries, addSemanticIndexes: addSemanticIndexes,);

  Widget sliverVariedExtentListlist({Key? key, required ItemExtentBuilder itemExtentBuilder, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true,}) =>
    SliverVariedExtentList.list(children: this, key: key, itemExtentBuilder: itemExtentBuilder, addAutomaticKeepAlives: addAutomaticKeepAlives, addRepaintBoundaries: addRepaintBoundaries, addSemanticIndexes: addSemanticIndexes,);

  Widget sliverGridcount({Key? key, required int crossAxisCount, double mainAxisSpacing = 0.0, double crossAxisSpacing = 0.0, double childAspectRatio = 1.0,}) =>
    SliverGrid.count(children: this, key: key, crossAxisCount: crossAxisCount, mainAxisSpacing: mainAxisSpacing, crossAxisSpacing: crossAxisSpacing, childAspectRatio: childAspectRatio,);

  Widget sliverGridextent({Key? key, required double maxCrossAxisExtent, double mainAxisSpacing = 0.0, double crossAxisSpacing = 0.0, double childAspectRatio = 1.0,}) =>
    SliverGrid.extent(children: this, key: key, maxCrossAxisExtent: maxCrossAxisExtent, mainAxisSpacing: mainAxisSpacing, crossAxisSpacing: crossAxisSpacing, childAspectRatio: childAspectRatio,);

  Widget sliverCrossAxisGroup({Key? key,}) =>
    SliverCrossAxisGroup(slivers: this, key: key,);

  Widget sliverMainAxisGroup({Key? key,}) =>
    SliverMainAxisGroup(slivers: this, key: key,);

  Widget customScrollView({Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, ScrollBehavior? scrollBehavior, bool shrinkWrap = false, Key? center, double anchor = 0.0, double? cacheExtent, int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge, HitTestBehavior hitTestBehavior = HitTestBehavior.opaque,}) =>
    CustomScrollView(slivers: this, key: key, scrollDirection: scrollDirection, reverse: reverse, controller: controller, primary: primary, physics: physics, scrollBehavior: scrollBehavior, shrinkWrap: shrinkWrap, center: center, anchor: anchor, cacheExtent: cacheExtent, semanticChildCount: semanticChildCount, dragStartBehavior: dragStartBehavior, keyboardDismissBehavior: keyboardDismissBehavior, restorationId: restorationId, clipBehavior: clipBehavior, hitTestBehavior: hitTestBehavior,);

  Widget listView({Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, EdgeInsetsGeometry? padding, double? itemExtent, ItemExtentBuilder? itemExtentBuilder, Widget? prototypeItem, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true, double? cacheExtent, int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge, HitTestBehavior hitTestBehavior = HitTestBehavior.opaque,}) =>
    ListView(children: this, key: key, scrollDirection: scrollDirection, reverse: reverse, controller: controller, primary: primary, physics: physics, shrinkWrap: shrinkWrap, padding: padding, itemExtent: itemExtent, itemExtentBuilder: itemExtentBuilder, prototypeItem: prototypeItem, addAutomaticKeepAlives: addAutomaticKeepAlives, addRepaintBoundaries: addRepaintBoundaries, addSemanticIndexes: addSemanticIndexes, cacheExtent: cacheExtent, semanticChildCount: semanticChildCount, dragStartBehavior: dragStartBehavior, keyboardDismissBehavior: keyboardDismissBehavior, restorationId: restorationId, clipBehavior: clipBehavior, hitTestBehavior: hitTestBehavior,);

  Widget gridView({Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, EdgeInsetsGeometry? padding, required SliverGridDelegate gridDelegate, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true, double? cacheExtent, int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, Clip clipBehavior = Clip.hardEdge, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, HitTestBehavior hitTestBehavior = HitTestBehavior.opaque,}) =>
    GridView(children: this, key: key, scrollDirection: scrollDirection, reverse: reverse, controller: controller, primary: primary, physics: physics, shrinkWrap: shrinkWrap, padding: padding, gridDelegate: gridDelegate, addAutomaticKeepAlives: addAutomaticKeepAlives, addRepaintBoundaries: addRepaintBoundaries, addSemanticIndexes: addSemanticIndexes, cacheExtent: cacheExtent, semanticChildCount: semanticChildCount, dragStartBehavior: dragStartBehavior, clipBehavior: clipBehavior, keyboardDismissBehavior: keyboardDismissBehavior, restorationId: restorationId, hitTestBehavior: hitTestBehavior,);

  Widget gridViewcount({Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, EdgeInsetsGeometry? padding, required int crossAxisCount, double mainAxisSpacing = 0.0, double crossAxisSpacing = 0.0, double childAspectRatio = 1.0, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true, double? cacheExtent, int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge, HitTestBehavior hitTestBehavior = HitTestBehavior.opaque,}) =>
    GridView.count(children: this, key: key, scrollDirection: scrollDirection, reverse: reverse, controller: controller, primary: primary, physics: physics, shrinkWrap: shrinkWrap, padding: padding, crossAxisCount: crossAxisCount, mainAxisSpacing: mainAxisSpacing, crossAxisSpacing: crossAxisSpacing, childAspectRatio: childAspectRatio, addAutomaticKeepAlives: addAutomaticKeepAlives, addRepaintBoundaries: addRepaintBoundaries, addSemanticIndexes: addSemanticIndexes, cacheExtent: cacheExtent, semanticChildCount: semanticChildCount, dragStartBehavior: dragStartBehavior, keyboardDismissBehavior: keyboardDismissBehavior, restorationId: restorationId, clipBehavior: clipBehavior, hitTestBehavior: hitTestBehavior,);

  Widget gridViewextent({Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, EdgeInsetsGeometry? padding, required double maxCrossAxisExtent, double mainAxisSpacing = 0.0, double crossAxisSpacing = 0.0, double childAspectRatio = 1.0, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true, double? cacheExtent, int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge, HitTestBehavior hitTestBehavior = HitTestBehavior.opaque,}) =>
    GridView.extent(children: this, key: key, scrollDirection: scrollDirection, reverse: reverse, controller: controller, primary: primary, physics: physics, shrinkWrap: shrinkWrap, padding: padding, maxCrossAxisExtent: maxCrossAxisExtent, mainAxisSpacing: mainAxisSpacing, crossAxisSpacing: crossAxisSpacing, childAspectRatio: childAspectRatio, addAutomaticKeepAlives: addAutomaticKeepAlives, addRepaintBoundaries: addRepaintBoundaries, addSemanticIndexes: addSemanticIndexes, cacheExtent: cacheExtent, semanticChildCount: semanticChildCount, dragStartBehavior: dragStartBehavior, keyboardDismissBehavior: keyboardDismissBehavior, restorationId: restorationId, clipBehavior: clipBehavior, hitTestBehavior: hitTestBehavior,);

}

/// const value
const _kDefaultDiameterRatio = 1.07;

const _kSqueeze = 1.45;

const _kDefaultRowsMargin = EdgeInsets.only(bottom: 8.0);

const _kBaseDividerMargin = 20.0;

const _kMarginTop = 22.0;

const _kInsetDividerMargin = 14.0;

const _kFormDefaultInsetGroupedRowsMargin = EdgeInsetsDirectional.fromSTEB(20.0, 0.0, 20.0, 10.0);

Widget _defaultContextMenuBuilder(BuildContext context, SelectableRegionState selectableRegionState) {return AdaptiveTextSelectionToolbar.selectableRegion(selectableRegionState: selectableRegionState);}

class _DefaultHeroTag {const _DefaultHeroTag(); @override String toString() => '<default FloatingActionButton tag>';}

const _kMobilePlatforms = <TargetPlatform>{TargetPlatform.android, TargetPlatform.iOS, TargetPlatform.fuchsia};

class _DefaultSnapshotPainter implements SnapshotPainter {const _DefaultSnapshotPainter(); @override void addListener(ui.VoidCallback listener) {} @override void dispose() {} @override bool get hasListeners => false; @override void notifyListeners() {} @override void paint(PaintingContext context, ui.Offset offset, ui.Size size, PaintingContextCallback painter) {painter(context, offset);} @override void paintSnapshot(PaintingContext context, ui.Offset offset, ui.Size size, ui.Image image, Size sourceSize, double pixelRatio) {final Rect src = Rect.fromLTWH(0, 0, sourceSize.width, sourceSize.height); final Rect dst = Rect.fromLTWH(offset.dx, offset.dy, size.width, size.height); final Paint paint = Paint()..filterQuality = FilterQuality.medium; context.canvas.drawImageRect(image, src, dst, paint);} @override void removeListener(ui.VoidCallback listener) {} @override bool shouldRepaint(covariant _DefaultSnapshotPainter oldPainter) => false;}

const _kColor = Color(0xA0B71C1C);

const _kTextStyle = TextStyle(color: Color(0xFFFFFFFF), fontSize: _kHeight * 0.85, fontWeight: FontWeight.w900, height: 1.0);

const _kHeight = 12.0;

const _kShadow = BoxShadow(color: Color(0x7F000000), blurRadius: 6.0);

const _kDrag = 0.0000135;

const _kMinThumbExtent = 18.0;

const _kScrollbarFadeDuration = Duration(milliseconds: 300);

const _kScrollbarTimeToFade = Duration(milliseconds: 600);


